<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>The RDKit/Postgres Ordered Substructure Search Problem | Depth-First</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Diagnosis and partial solution to a thorny performance issue affecting simple queries.">
    <meta name="generator" content="Hugo 0.139.4">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/articles/2021-08-11-the-rdkit-postgres-ordered-substructure-search-problem/">
    

    <meta property="og:url" content="http://localhost:1313/articles/2021-08-11-the-rdkit-postgres-ordered-substructure-search-problem/">
  <meta property="og:site_name" content="Depth-First">
  <meta property="og:title" content="The RDKit/Postgres Ordered Substructure Search Problem">
  <meta property="og:description" content="Diagnosis and partial solution to a thorny performance issue affecting simple queries.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2021-08-11T15:00:00+00:00">
    <meta property="article:modified_time" content="2021-08-11T15:00:00+00:00">

  <meta itemprop="name" content="The RDKit/Postgres Ordered Substructure Search Problem">
  <meta itemprop="description" content="Diagnosis and partial solution to a thorny performance issue affecting simple queries.">
  <meta itemprop="datePublished" content="2021-08-11T15:00:00+00:00">
  <meta itemprop="dateModified" content="2021-08-11T15:00:00+00:00">
  <meta itemprop="wordCount" content="2522">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="The RDKit/Postgres Ordered Substructure Search Problem">
  <meta name="twitter:description" content="Diagnosis and partial solution to a thorny performance issue affecting simple queries.">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Depth-First
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Articles
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">The RDKit/Postgres Ordered Substructure Search Problem</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2021-08-11T15:00:00Z">August 11, 2021</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p><a href="/articles/2021/07/28/rdkit-postgres-cartridge/">The RDKit Postgres extension</a> (&ldquo;the extension&rdquo;) enables fast chemical substructure queries in plain SQL. Convenience is the main selling point of this utility, which allows low-level data processing to stay within the database layer of an application. While evaluating RDKit for use in a revamped commercial product, I uncovered an easily-detected, show-stopping performance issue that to my knowledge has never been documented before. This article summarizes what I found, and presents a workaround that may or may not be suitable for production environments.</p>
<p>Before we begin, a disclaimer: I don&rsquo;t know what I don&rsquo;t know. It&rsquo;s quite possible that I&rsquo;m missing something too obvious to document. Or that I&rsquo;m misunderstanding the issues entirely. Keep these points (and <a href="https://en.wikipedia.org/wiki/Ward_Cunningham#%22Cunningham's_Law%22">Cunningham&rsquo;s Law</a>) in mind when reading the following account.</p>
<h1 id="the-goal">The Goal</h1>
<p>The goal of this study was to use the extension to search a collection of 100,000 small molecules by substructure, ordering the results by increasing molecular weight. Such a query could be used with a large database backing an online structure search system in which some scalar, such as molecular weight, is associated with relevance. Sorting allows the most relevant hits to appear first, which can be crucial when techniques such as <a href="https://use-the-index-luke.com/no-offset">keyset pagination</a> are used.</p>
<h1 id="the-system">The System</h1>
<p>A table having 100,000 rows was prepared using a procedure similar to the one <a href="/articles/2021/07/28/rdkit-postgres-cartridge/">previously reported</a> and described in detail at the end of this article. The specifications for the DBMS itself were:</p>
<ul>
<li>Postgres 12.3</li>
<li>RDKit extension 0.74.0 compiled for Linux</li>
<li>database run in Docker from <a href="https://hub.docker.com/r/mcs07/postgres-rdkit">this image</a></li>
<li>stock install with no customizations</li>
</ul>
<p>The table contained the following columns and indexes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">\</span>d molecules
</span></span><span style="display:flex;"><span><span style="color:#75715e">--                              Table &#34;public.molecules&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Column |   Type    | Collation | Nullable |                Default                
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- --------+-----------+-----------+----------+---------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  id     | integer   |           | not null | nextval(&#39;molecules_id_seq&#39;::regclass)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  mol    | mol       |           | not null | 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  mw     | numeric   |           | not null | 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  fp     | bit(1024) |           |          | 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- Indexes:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--     &#34;molecules_pkey&#34; PRIMARY KEY, btree (id)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--     &#34;molecules_mol&#34; gist (mol)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--     &#34;molecules_mw&#34; btree (mw)
</span></span></span></code></pre></div><p>Query timings were those reported Postgres:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">\</span>timing
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Timing is on.
</span></span></span></code></pre></div><h1 id="ordered-and-unordered-substructure-search">Ordered and Unordered Substructure Search</h1>
<p>Substructure-only queries were uniformly fast, typically executing within 10 ms regardless of the SMILES used. Benzene was tested as a particularly tough case in that <a href="/articles/2008/10/02/fast-substructure-search-using-open-source-tools-part-1-fingerprints-and-databases/">fingerprint prescreening</a> is likely to filter few candidates.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> mol, mw <span style="color:#66d9ef">FROM</span> molecules <span style="color:#66d9ef">WHERE</span> mol<span style="color:#f92672">@&gt;</span><span style="color:#e6db74">&#39;c1ccccc1&#39;</span> <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">--                            mol                            |   mw    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- ----------------------------------------------------------+---------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  CCNC(=O)C1(Cc2cccc(-c3ccccc3)c2)CCN(C(=O)CC)CC1          | 378.516
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  CCNC(=O)C1(Cc2cccc(-c3ccccc3)c2)CCN(C(=O)C(C)C)CC1       | 392.543
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- Time: 8.541 ms
</span></span></span></code></pre></div><p>Surprisingly, the same query with an <code>ORDER BY</code> clause increased the time to completion by over 200-fold:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> mol, mw <span style="color:#66d9ef">FROM</span> molecules <span style="color:#66d9ef">WHERE</span> mol<span style="color:#f92672">@&gt;</span><span style="color:#e6db74">&#39;c1ccccc1&#39;</span> <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> mw <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">--            mol           |   mw    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- -------------------------+---------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  C=C=Cc1ccccc1           | 116.163
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  C=Cc1cccc(O)c1          | 120.151
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- Time: 1975.443 ms (00:01.975)
</span></span></span></code></pre></div><p>In general, the more feature-rich the query SMILES, the faster the query. This didn&rsquo;t always correlate with molecular weight. For example, a search for acyl chlorides (<code>C(=O)Cl</code>) finished with comparable times in unordered and ordered form (5.96 ms and 6.30 ms, respectively).</p>
<p>The slow ordered query response for benzene and other simple substructures appears to scale linearly with the number of records. Given a table of 1M rows (10x larger), the ordered benzene query returned in 25 seconds (10x slower), whereas the unordered benzene query returned in fewer than 10 ms. Response times longer than one second represent the upper bound of acceptable performance for the system I&rsquo;m looking at. Such poor performance for ordered substructure queries is unexpected in light of the fast responses seen across the board with unordered queries.</p>
<p>Something is causing Postgres to do the wrong thing, but what is it?</p>
<h1 id="diagnosis-attempts">Diagnosis Attempts</h1>
<p>Postgres comes with a suite of tools for diagnosing performance issues. In particular, <a href="https://www.postgresql.org/docs/12/sql-explain.html"><code>EXPLAIN ANALYZE</code></a> can give insights into specific steps used to execute a query, including the indexes and algorithms used.</p>
<p>For example, running <code>EXPLAIN ANALYZE</code> on an unordered benzene substructure query revealed that Postgres used the RDKit index as expected:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">ANALYZE</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> mol, mw <span style="color:#66d9ef">FROM</span> molecules <span style="color:#66d9ef">WHERE</span> mol<span style="color:#f92672">@&gt;</span><span style="color:#e6db74">&#39;c1ccccc1&#39;</span> <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">--                                                               QUERY PLAN                                                              
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- --------------------------------------------------------------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Limit  (cost=0.28..106.72 rows=25 width=403) (actual time=0.608..1.551 rows=25 loops=1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--    -&gt;  Index Scan using molecules_mol on molecules  (cost=0.28..426.03 rows=100 width=403) (actual time=0.607..1.544 rows=25 loops=1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--          Index Cond: (mol @&gt; &#39;c1ccccc1&#39;::mol)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Planning Time: 0.081 ms
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Execution Time: 1.698 ms
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- (5 rows)
</span></span></span></code></pre></div><p>The <a href="https://www.postgresql.org/docs/9.3/index-scanning.html">Index Scan</a> node tells us that that <code>molecules_mol</code> index is being used, as expected.</p>
<p>A different kind of report resulted from running <code>EXPLAIN ANALYZE</code> on the same substructure query, but ordered by molecular weight:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">ANALYZE</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> mol, mw <span style="color:#66d9ef">FROM</span> molecules <span style="color:#66d9ef">WHERE</span> mol<span style="color:#f92672">@&gt;</span><span style="color:#e6db74">&#39;c1ccccc1&#39;</span> <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> mw <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">--                                                                 QUERY PLAN                                                                 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- -------------------------------------------------------------------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Limit  (cost=388.74..388.80 rows=25 width=403) (actual time=1925.578..1925.582 rows=25 loops=1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--    -&gt;  Sort  (cost=388.74..388.99 rows=100 width=403) (actual time=1925.576..1925.578 rows=25 loops=1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--          Sort Key: mw
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--          Sort Method: top-N heapsort  Memory: 41kB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--          -&gt;  Bitmap Heap Scan on molecules  (cost=25.05..385.92 rows=100 width=403) (actual time=48.888..1879.645 rows=66316 loops=1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--                Recheck Cond: (mol @&gt; &#39;c1ccccc1&#39;::mol)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--                Rows Removed by Index Recheck: 3752
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--                Heap Blocks: exact=5366
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--                -&gt;  Bitmap Index Scan on molecules_mol  (cost=0.00..25.03 rows=100 width=0) (actual time=48.138..48.138 rows=70068 loops=1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--                      Index Cond: (mol @&gt; &#39;c1ccccc1&#39;::mol)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Planning Time: 0.109 ms
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Execution Time: 1925.723 ms
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- (12 rows)
</span></span></span></code></pre></div><p>Although both columns, <code>mol</code> and <code>mw</code> are indexed, Postgres only uses the one on <code>mol</code>. The index on <code>mw</code>, which otherwise would be used for sorting efficiently, is ignored. In its place, the query planner opts for a much less efficient &ldquo;top-N heapsort&rdquo;. The use of heapsort instead of an index scan causes the slowdown, as we&rsquo;ll soon see.</p>
<p>Understanding complex query plans like this can take some practice. Fortunately, there are some good resources. One of them, an online course from the University of Tübingen, deals with understanding a query plan similar to what see above.</p>
<!-- raw HTML omitted -->
<p>Important takeaways from the query plan:</p>
<ul>
<li>There are no &ldquo;lossy&rdquo; heap blocks, meaning that the bitmap created from the index scan fits entirely into working memory (<code>work_mem</code>). Fiddling with this parameter, as is often recommended, will not help.</li>
<li>The Bitmap Index Scan has to deal with 70,068 rows, which is over half of them.</li>
<li>The heapsort has to deal with 66,316 rows.</li>
</ul>
<p>We gain additional insights from the query plan for the substructure search on acyl chlorides (<code>C(=O)Cl</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">ANALYZE</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> mol, mw <span style="color:#66d9ef">FROM</span> molecules <span style="color:#66d9ef">WHERE</span> mol<span style="color:#f92672">@&gt;</span><span style="color:#e6db74">&#39;C(=O)Cl&#39;</span> <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> mw <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">--                                                               QUERY PLAN                                                              
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- --------------------------------------------------------------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Limit  (cost=388.74..388.80 rows=25 width=403) (actual time=0.747..0.750 rows=17 loops=1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--    -&gt;  Sort  (cost=388.74..388.99 rows=100 width=403) (actual time=0.746..0.747 rows=17 loops=1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--          Sort Key: mw
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--          Sort Method: quicksort  Memory: 30kB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--          -&gt;  Bitmap Heap Scan on molecules  (cost=25.05..385.92 rows=100 width=403) (actual time=0.261..0.722 rows=17 loops=1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--                Recheck Cond: (mol @&gt; &#39;O=CCl&#39;::mol)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--                Heap Blocks: exact=14
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--                -&gt;  Bitmap Index Scan on molecules_mol  (cost=0.00..25.03 rows=100 width=0) (actual time=0.204..0.204 rows=17 loops=1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--                      Index Cond: (mol @&gt; &#39;O=CCl&#39;::mol)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Planning Time: 0.096 ms
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Execution Time: 0.841 ms
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- (11 rows)
</span></span></span></code></pre></div><p>Regardless of the substructure query, the planner has decided to favor an outer sort over an index scan to deliver the ordering required by substructure queries. Given a sufficiently precise query (and correspondingly dense fingerprint), that works out well. However, in the case of vague queries with sparse fingerprints, it does not.</p>
<p>Before explaining the workaround, a few words on things that didn&rsquo;t work are in order.</p>
<h1 id="things-that-didnt-work">Things that Didn&rsquo;t Work</h1>
<p>Advice for optimizing Postgres queries often involves increasing memory. Two setting are usually involved:</p>
<ul>
<li><code>work_mem</code>. As noted previously, one thing held in working memory is bitmaps. The query planner has already told us that there is plenty of this kind of memory. Unsurprisingly, adjusting <code>work_mem</code> upward had no effect.</li>
<li><code>shared_buffers</code>. As noted by <a href="https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server">the Wiki</a>, this setting &ldquo;determines how much memory is dedicated to PostgreSQL to use for caching data.&rdquo;</li>
</ul>
<p>To explore the possibility that increasing <code>shared_buffers</code> might persuade Postgres to start using the <code>mw</code> index, <code>shared_buffers</code> was adjusted upward from the default of 128 MB to 2048 MB. This had no effect on the query plan or execution time.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">system</span> <span style="color:#66d9ef">set</span> shared_buffers <span style="color:#66d9ef">to</span> <span style="color:#e6db74">&#39;2048MB&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- exit, then restart
</span></span></span></code></pre></div><p>Perhaps the query planner needs a two-column index on <code>mw</code> and <code>mol</code>. Although the documentation makes it clear that this should not be necessary, various sources suggest that it could be. Regardless, setting a two column index did not lead to faster queries. Doing this was a little tricky because <code>mw</code> requires a b-tree index whereas <code>mol</code> requires a GIST index. The two types can&rsquo;t ordinarily be mixed in a multicolumn index. However, this can be corrected by installing the <a href="https://www.postgresql.org/docs/9.1/btree-gist.html">btree_gist extension</a>.</p>
<h1 id="a-workaround">A Workaround</h1>
<p>If the query planner insists of sorting, is there a way to disable it? It turns out that Postgres supports the boolean parameter <code>enable_sort</code>. According to the <a href="https://www.postgresql.org/docs/9.5/runtime-config-query.html">documentation</a>, <code>enable_sort</code>:</p>
<blockquote>
<p>Enables or disables the query planner&rsquo;s use of explicit sort steps. It is impossible to suppress explicit sorts entirely, but turning this variable off discourages the planner from using one if there are other methods available. The default is on.</p>
</blockquote>
<p>This parameter defaults to &ldquo;on&rdquo;. It can be turned off as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- https://stackoverflow.com/a/63796329/54426
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">set</span> enable_sort<span style="color:#f92672">=</span><span style="color:#66d9ef">off</span>;
</span></span></code></pre></div><p>The effect was dramatic, and similar response times were seen with or without the <code>ORDER BY</code> clause:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> mol, mw <span style="color:#66d9ef">FROM</span> molecules <span style="color:#66d9ef">WHERE</span> mol<span style="color:#f92672">@&gt;</span><span style="color:#e6db74">&#39;c1ccccc1&#39;</span> <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> mw <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">--            mol           |   mw    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- -------------------------+---------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  C=C=Cc1ccccc1           | 116.163
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  C=Cc1ccccc1O            | 120.151
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Time: 14.705 ms
</span></span></span></code></pre></div><p>Instead of a sort, the planner now uses both indexes as expected:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">ANALYZE</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> mol, mw <span style="color:#66d9ef">FROM</span> molecules <span style="color:#66d9ef">WHERE</span> mol<span style="color:#f92672">@&gt;</span><span style="color:#e6db74">&#39;c1ccccc1&#39;</span> <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> mw <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">--                                                               QUERY PLAN                                                               
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- ---------------------------------------------------------------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Limit  (cost=0.42..6145.87 rows=25 width=403) (actual time=2.043..6.476 rows=25 loops=1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--    -&gt;  Index Scan using molecules_mw on molecules  (cost=0.42..24582.23 rows=100 width=403) (actual time=2.041..6.466 rows=25 loops=1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--          Filter: (mol @&gt; &#39;c1ccccc1&#39;::mol)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--          Rows Removed by Filter: 355
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Planning Time: 0.092 ms
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  Execution Time: 6.528 ms
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- (6 rows)
</span></span></span></code></pre></div><p>As an aside, the above query plan was also returned without adjusting <code>enable_sort</code> when the number of rows was 10,000 instead of the 100,000 used here. It&rsquo;s possible that adjusting some other, less-invasive Postgres operational parameter would address the ordered substructure query problem in a better way.</p>
<p>Globally setting <code>enable_sort</code> is probably not a good idea, but fortunately, it can be set on a per-transaction basis. After completion of the transaction, <code>enable_sort</code> is restored to its default setting of &ldquo;off&rdquo;.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">BEGIN</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> <span style="color:#66d9ef">LOCAL</span> enable_sort <span style="color:#f92672">=</span> <span style="color:#66d9ef">off</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> mol, mw <span style="color:#66d9ef">FROM</span> molecules <span style="color:#66d9ef">WHERE</span> mol<span style="color:#f92672">@&gt;</span><span style="color:#e6db74">&#39;c1ccccc1&#39;</span> <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> mw <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">COMMIT</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- BEGIN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- Time: 2.565 ms
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- SET
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- Time: 4.357 ms
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--            mol           |   mw    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- -------------------------+---------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  C=C=Cc1ccccc1           | 116.163
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  C=Cc1ccccc1O            | 120.151
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- Time: 11.117 ms
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- COMMIT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- Time: 3.667 ms
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">show</span> enable_sort;
</span></span><span style="display:flex;"><span><span style="color:#75715e">--  enable_sort 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- -------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- (1 row)
</span></span></span></code></pre></div><p>What about larger databases? The workaround does the trick there as well. In a similarly-constructed database of 1M eMolecules records, unsetting <code>enable_sort</code> results in queries on the order of 10-20 ms compared to queries in the 20-30 second range without the workaround.</p>
<p>It&rsquo;s possible that the problem lies with the RDKit extension itself. My reading of the documentation suggests that it is the duty of extensions to provide the planner with the information needed to estimate costs. This takes the form of a &ldquo;Scan Provider.&rdquo; Perhaps the extension&rsquo;s Scan Provider is faulty, or not implemented. <a href="https://wiki.postgresql.org/wiki/CustomScanInterface">The Wiki</a> has this to say on the topic:</p>
<blockquote>
<p>Prior to query execution, the PostgreSQL planner constructs a plan tree that usually consists of built-in plan nodes (IE: SeqScan, HashJoin, etc). The custom-scan interface allows extensions to create a custom-scan provider that implements its own logic, in addition to the built-in nodes, for scanning relations. If a custom-scan node is chosen by the planner, callback functions associated with this custom-scan node shall be invoked during query execution. The custom-scan provider is responsible for returning equivalent result set as built-in logic would, but it is free to scan the relation according to its own logic.</p>
<p>This chapter explains how to write a custom-scan provider.</p>
</blockquote>
<h1 id="other-work">Other Work</h1>
<p>Perhaps the most surprising thing about the ordered substructure query problem is that it has never been documented before, at least to my knowledge. I did find hints, but nothing like what&rsquo;s outlined here — not even a recognition of the problem.</p>
<ul>
<li><a href="http://rdkit.blogspot.com/2013/11/substructure-fingerprints-and-cartridge.html">Substructure fingerprints and the PostgreSQL cartridge</a>. A blog post from 2013 discussing the performance gains from using fingerprint indexes. However, no discussion of sorting appears.</li>
<li><a href="http://rdkit.blogspot.com/2013/11/substructure-fingerprints-and-chembl.html">Substructure fingerprints and the PostgreSQL cartridge 2: Application to ChEMBL</a>. Follow up post that also never mentions sorting substructure queries.</li>
<li><a href="https://sourceforge.net/p/rdkit/mailman/rdkit-discuss/thread/CAKwxoo6m9y2cb65qiotPFwMxCBTP5S%3D2BLQ08XPe-wAUbYNgyw%40mail.gmail.com/#msg32604355">[Rdkit-discuss] Need for speed &ndash; postgresql / rdkit use of indices(/indexes)</a>. An email thread from 2014 discussing slow queries with structures like benzene on unlimited, unordered, large databases. Discusses query plan, the abandonment of indexes, and moderately successful interventions.</li>
</ul>
<h1 id="resources">Resources</h1>
<p>For understanding Postgres indexes, query plans, and performance, I can recommend these resources:</p>
<ul>
<li><a href="https://github.com/evgeniy-khist/postgresql-performance-essentials">PostgreSQL Performance Essentials in 1 Hour</a></li>
<li><a href="https://www.youtube.com/watch?v=pq8KHeqS2NU">University of Tübingen DB 2 Course (Internals of Relational Database Systems)</a></li>
</ul>
<h1 id="building-the-database">Building the Database</h1>
<p>The database was built from a subset of the <a href="https://downloads.emolecules.com/free/">eMolecules public download files</a>. First, obtain the raw data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wget https://downloads.emolecules.com/free/2021-07-01/version.smi.gz
</span></span></code></pre></div><p>With an unmodified instance of the extension running on Postgres in a Docker container, create the database, extension, and raw data table. Then populate this table with the first 100,000 entries from the eMolecules set.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>createdb emolecules
</span></span><span style="display:flex;"><span>psql -c <span style="color:#e6db74">&#39;create extension rdkit&#39;</span> emolecules
</span></span><span style="display:flex;"><span>psql -c <span style="color:#e6db74">&#39;create table raw_data(id SERIAL, smiles text, version_id integer, parent_id integer);&#39;</span> emolecules
</span></span><span style="display:flex;"><span>zcat &lt; ./version.smi.gz | sed <span style="color:#e6db74">&#39;1d; s/\\/\\\\/g&#39;</span> | head -n <span style="color:#ae81ff">1000000</span> | psql -c <span style="color:#e6db74">&#34;copy raw_data (smiles,version_id,parent_id) from stdin with delimiter &#39; &#39;&#34;</span> emolecules
</span></span></code></pre></div><p>Log into Postgres, then place the processed raw data into a new table, <code>molecules</code>.</p>
<pre tabindex="0"><code>psql emolecules
psql (13.3, server 12.3 (Debian 12.3-1.pgdg100+1))
Type &#34;help&#34; for help.

emolecules=# select count(*) from raw_data;
  count  
---------
 1000000
(1 row)
</code></pre><p>Now create the <code>molecules</code> table.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> molecules (id SERIAL <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>                        mol mol <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>                        mw NUMERIC <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>                        fp bit(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>                       );
</span></span></code></pre></div><p>Populate the <code>molecules</code> table with source data from the <code>raw_data</code> table.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> molecules
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> nextval(<span style="color:#e6db74">&#39;molecules_id_seq&#39;</span>),
</span></span><span style="display:flex;"><span>       mols.mol <span style="color:#66d9ef">as</span> mol,
</span></span><span style="display:flex;"><span>       mol_amw(mols.mol) <span style="color:#66d9ef">as</span> mw,
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">right</span>(bfp_to_binary_text(rdkit_fp(mols.mol))::text, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)::bit(<span style="color:#ae81ff">1024</span>) <span style="color:#66d9ef">as</span> fp
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">FROM</span> (<span style="color:#66d9ef">SELECT</span> mol_from_smiles(smiles::cstring) <span style="color:#66d9ef">as</span> mol
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">FROM</span> raw_data
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">100000</span>
</span></span><span style="display:flex;"><span>       ) <span style="color:#66d9ef">as</span> mols
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">WHERE</span> mol <span style="color:#66d9ef">IS</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>;
</span></span></code></pre></div><p>This takes a few minutes. On completion, 100,000 records will be present in the <code>molecules</code> table.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">from</span> molecules;
</span></span><span style="display:flex;"><span><span style="color:#75715e">--  count  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- --------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--  100000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- (1 row)
</span></span></span></code></pre></div><p>Finally, create indexes on the <code>mol</code> (molecule) and <code>mw</code> (molecular weight) columns.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> molecules_mol <span style="color:#66d9ef">ON</span> molecules <span style="color:#66d9ef">USING</span> gist(mol);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> molecules_mw <span style="color:#66d9ef">on</span> molecules <span style="color:#66d9ef">USING</span> btree(mw);
</span></span></code></pre></div><p>The procedure can be repeated with a higher <code>LIMIT</code> to insert more rows into the <code>molecules</code> table.</p>
<h1 id="conclusion">Conclusion</h1>
<p>The RDKit Postgres extension can be an extremely useful tool for building data-centric applications. For simple unordered structure queries of the kind presented in tutorials, it performs uniformly well. However, in some situations, the interaction between the extension and the query planner can lead to surprisingly bad performance. This article highlighted one such case. The problem was diagnosed and resolved through a workaround. However, the generality of this solution remains to be seen. It&rsquo;s possible that a more robust solution will require changes to the extension itself, or a different approach altogether.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Depth-First 2024 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
