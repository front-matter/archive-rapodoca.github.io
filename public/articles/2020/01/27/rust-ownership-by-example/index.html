<!DOCTYPE html>
<html lang="en-us" dir="ltr" class="scroll-smooth" data-default-appearance="light"
  data-auto-appearance="true"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  
  <meta http-equiv="content-language" content="en-us" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  
  <title>Rust Ownership by Example &middot; Depth-First</title>
  <meta name="title" content="Rust Ownership by Example &middot; Depth-First" />
  
  <meta name="description" content="A deep dive for beginners into Rust&#39;s most important big idea." />
  
  
  
  <link rel="canonical" href="http://localhost:1313/articles/2020/01/27/rust-ownership-by-example/" />
  
  
  
  
  
  
  
  
  
  
  <link type="text/css" rel="stylesheet" href="/css/main.bundle.min.e27868ab1485f7ed7b06b122b4980bd38b19526eb8f7de885181204d28f04a0c47e9c334eff19a06c0278eb2ff8415b983a5d0fb80fd6b5680c926457cc61c57.css"
    integrity="sha512-4nhoqxSF9&#43;17BrEitJgL04sZUm64996IUYEgTSjwSgxH6cM07/GaBsAnjrL/hBW5g6XQ&#43;4D9a1aAySZFfMYcVw==" />
  
  
  <script type="text/javascript" src="/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js"
    integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj&#43;e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script>
  
  
  
  
  
  
  
  
  
  
  
  <script defer type="text/javascript" id="script-bundle" src="/js/main.bundle.min.c178288131a2f1ad46910438db47ac5f7e1c48cf949e49f6dc3310c8ec9660e23fe505805eba4e2e73711335808500360d773a2b64322feb35df52856edca286.js"
    integrity="sha512-wXgogTGi8a1GkQQ420esX34cSM&#43;Unkn23DMQyOyWYOI/5QWAXrpOLnNxEzWAhQA2DXc6K2QyL&#43;s131KFbtyihg==" data-copy="" data-copied=""></script>
  
  
  
  <script src="/lib/zoom/zoom.min.37d2094687372da3f7343a221a470f6b8806f7891aa46a5a03966af7f0ebd38b9fe536cb154e6ad28f006d184b294525a7c4054b6bbb4be62d8b453b42db99bd.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S&#43;Yti0U7QtuZvQ=="></script>
  
  
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
  <link rel="manifest" href="/site.webmanifest" />
  
  
  
  
  
  
  
  
  <meta property="og:url" content="http://localhost:1313/articles/2020/01/27/rust-ownership-by-example/">
  <meta property="og:site_name" content="Depth-First">
  <meta property="og:title" content="Rust Ownership by Example">
  <meta property="og:description" content="A deep dive for beginners into Rust’s most important big idea.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-01-27T14:00:00+00:00">
    <meta property="article:modified_time" content="2020-01-27T14:00:00+00:00">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Rust Ownership by Example">
  <meta name="twitter:description" content="A deep dive for beginners into Rust’s most important big idea.">

  
  <script type="application/ld+json">
  [{
    "@context": "https://schema.org",
    "@type": "Article",
    "articleSection": "Posts",
    "name": "Rust Ownership by Example",
    "headline": "Rust Ownership by Example",
    
    "abstract": "A deep dive for beginners into Rust\u0026rsquo;s most important big idea.",
    "inLanguage": "en-us",
    "url" : "http:\/\/localhost:1313\/articles\/2020\/01\/27\/rust-ownership-by-example\/",
    "author" : {
      "@type": "Person",
      "name": ""
    },
    "copyrightYear": "2020",
    "dateCreated": "2020-01-27T14:00:00\u002b00:00",
    "datePublished": "2020-01-27T14:00:00\u002b00:00",
    
    "dateModified": "2020-01-27T14:00:00\u002b00:00",
    
    
    
    "mainEntityOfPage": "true",
    "wordCount": "4108"
  }]
  </script>


  
  
  
  
  

<script src="/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js" integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj&#43;KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script>






















  
  



  
  
  <meta name="theme-color"/>
  
  
</head>
<body
  class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600">
  <div id="the-top" class="absolute flex self-center">
    <a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600"
      href="#main-content"><span
        class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>Skip to main content</a>
  </div>
  
  
  <div style="padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px"
    class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start space-x-3">
    
    <div class="flex flex-1 items-center justify-between">
        <nav class="flex space-x-3">

            
            <a href="/" class="text-base font-medium text-gray-500 hover:text-gray-900">Depth-First</a>
            

        </nav>
        <nav class="hidden md:flex items-center space-x-5 md:ml-12 h-12">

            

            


            
            <button id="search-button" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            


            
            
            <div
                class="ltr:mr-14 rtl:ml-14 flex items-center">
                <button id="appearance-switcher" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400">
                    <div class="flex items-center justify-center dark:hidden">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                    </div>
                    <div class="items-center justify-center hidden dark:flex">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                    </div>
                </button>
            </div>
            

        </nav>
        <div class="flex md:hidden items-center space-x-5 md:ml-12 h-12">

            <span></span>

            


            
            <button id="search-button-mobile" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            

            
            
            <button id="appearance-switcher-mobile" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400" style="margin-right:5px">
                <div class="flex items-center justify-center dark:hidden">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                </div>
                <div class="items-center justify-center hidden dark:flex">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                </div>
            </button>
            

        </div>
    </div>
    <div class="-my-2 -mr-2 md:hidden">

        <label id="menu-button" class="block">
            

            </div>
        </label>
    </div>
</div>





  
  <div class="relative flex flex-col grow">
    <main id="main-content" class="grow">
      


<article>
  

  <header id="single_header" class="mt-5 max-w-prose">
    
    <h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
      Rust Ownership by Example
    </h1>
    <div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden">
      





  
  







  





  



  













<div class="flex flex-row flex-wrap items-center">
  
  
  <time datetime="2020-01-27T14:00:00&#43;00:00">January 27, 2020</time><span class="px-2 text-primary-500">&middot;</span><span>4108 words</span><span class="px-2 text-primary-500">&middot;</span><span title="Reading time">20 mins</span>
  

  
  
</div>








    </div>

    
    
    
    
    

    

    
      
      
        
        
<div class="flex author">
  
  <div class="place-self-center">
    
    
    <div class="text-2xl sm:text-lg">
</div>
  </div>
</div>

      

      

      
      <div class="mb-5"></div>
      

    

  </header>
  
  <section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row">
    
    

      <div class="min-w-0 min-h-0 max-w-fit">
        
        


        <div class="article-content max-w-prose mb-20">
          <p><a href="https://www.rust-lang.org" target="_blank">Rust</a> is a safe systems programming language. Although C and C++ are systems languages, they&rsquo;re not safe. Specifically, Rust is a &ldquo;<a href="http://www.pl-enthusiast.net/2014/08/05/type-safety/" target="_blank">type safe language</a>&rdquo;, meaning that the compiler ensures that every program has well-defined behavior. Although other languages make the same guarantee, Rust does so without a garbage collector, runtime, or manual memory management.</p>
<p>Key to Rust&rsquo;s safety guarantee, and its most unusual feature, is the concept of <em>ownership</em>. When new Rust programmers run into trouble, the problem often boils down to ownership. Master ownership, and Rust will make a lot of sense. Ignore ownership, and you&rsquo;ll fight the compiler to accomplish even the simplest tasks.</p>
<p>This beginner Rust tutorial, unlike most others, features ownership front-and-center. Short examples highlight the practical consequences of ownership. I&rsquo;m no Rust expert. However, I have tried to choose examples that speak for themselves, and descriptions that jibe with reputable sources when possible.</p>


<h1 class="relative group">Getting Started 
    <div id="getting-started" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#getting-started" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>Running sample code and experimentation are very helpful for learning Rust. The easiest way to do that is to copy and paste the examples here into the <a href="https://play.rust-lang.org" target="_blank">Rust Playground</a> web application. If you&rsquo;d rather compile and run code on your own machine, the easiest way to do that is <a href="https://rustup.rs" target="_blank">rustup</a>.</p>


<h1 class="relative group">Ownership Begins with Assignment 
    <div id="ownership-begins-with-assignment" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#ownership-begins-with-assignment" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>Like other languages, Rust uses the equals symbol (<code>=</code>) to assign a value to a variable. The variable then serves as a handle for later use.</p>
<p>The following program assigns the literal value <code>42</code> to the variable <code>x</code>, then prints the value of <code>x</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;x: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But Rust takes assignment one step further. The assignee (<code>x</code>) becomes the value&rsquo;s sole owner. There are no exceptions. The tight coupling between assignment and ownership sets the stage for many of Rust&rsquo;s unique capabilities.</p>


<h1 class="relative group">Ownership Ends with Scope 
    <div id="ownership-ends-with-scope" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#ownership-ends-with-scope" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>When a variable goes out of scope, its associated value, if any, is <em>dropped</em>. A dropped value can never be used again because the resources it uses are immediately freed.</p>
<p>This rule makes it easy to reason about the liveness of values. For as long as a variable remains in scope, the value it owns will never be dropped. By the time the owner goes out of scope, its value will have been dropped. A value can be dropped before the end of a scope if the compiler determines that the owner is no longer used within the scope.</p>
<p>We can see this rule in action by assigning a variable within an anonymous scope created by the left and right curly brace characters (<code>{</code> and <code>}</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;x: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;x: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x); <span style="color:#75715e">// ERROR: x not in scope
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>The compiler rejects this code, informing us that the variable used in the second <code>println!</code> (<code>x</code>) is not in scope.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>8 |     println!(&#34;x: {}&#34;, x);
</span></span><span style="display:flex;"><span>  |                       ^ not found in this scope
</span></span></code></pre></div><p>Most languages would not allow you to use <code>x</code> outside of its local scope, either. But in Rust, this limitation goes further. When the anonymous scope ends, the value owned by <code>x</code> (<code>42</code>) is dropped.</p>
<p>A slightly more advanced example proves the order of events. Some explanation might be useful. We define a custom type <code>DropMe</code> that implements the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html" target="_blank"><code>Drop</code> trait</a> and its associated <code>drop</code> method. <code>drop</code> is called before an instance is dropped, printing a farewell message before digital oblivion. The remaining syntax will be explained later.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">DropMe</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Drop <span style="color:#66d9ef">for</span> DropMe {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">drop</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Dropping!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Begin outer scope.&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Begin inner scope.&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> DropMe;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;x: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;End outer scope.&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The program output demonstrates that the value owned by <code>x</code> is dropped when the variable goes out of scope:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>Begin outer scope.
</span></span><span style="display:flex;"><span>Begin inner scope.
</span></span><span style="display:flex;"><span>x: DropMe
</span></span><span style="display:flex;"><span>Dropping!
</span></span><span style="display:flex;"><span>End outer scope.
</span></span></code></pre></div>

<h1 class="relative group">Reassignment Moves Ownership 
    <div id="reassignment-moves-ownership" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#reassignment-moves-ownership" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>If assignment creates an ownership relationship, what about <em>reassignment</em>? Imagine we want to reassign the value owned by <code>a</code> to a new variable, <code>b</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]; <span style="color:#75715e">// a growable array literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> a;             <span style="color:#75715e">// move: `a` can no longer be used
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;b: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, b);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html" target="_blank">Vectors</a> (aka <code>Vec</code>) are Rust&rsquo;s growable array type. Vector literals are created with the <code>vec!</code> macro.</p>
<p>The above code compiles and runs, printing the result <code>b: [1, 2, 3]</code>. Following the rule that assignment creates an ownership relationship, we expect <code>b</code> to be the new owner. Given that a value can have only one owner, we further expect <code>a</code> to be uninitialized and therefore unusable. Both expectations are correct.</p>
<p>Reassignment of ownership (as in <code>let b = a</code>) is known as a <em>move</em>. A move causes the former assignee to become uninitialized and therefore not usable in the future.</p>
<p>We can confirm this by compiling:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;a: </span><span style="color:#e6db74">{:?}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">b: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, a, b); <span style="color:#75715e">// error: borrow of moved value: `a`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>The compiler detects our attempt to reuse the now uninitialized <code>a</code> and complains:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>2 |     let a = vec![1,2,3];
</span></span><span style="display:flex;"><span>  |         - move occurs because `a` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait
</span></span><span style="display:flex;"><span>3 |     let b = a;
</span></span><span style="display:flex;"><span>  |             - value moved here
</span></span><span style="display:flex;"><span>4 | 
</span></span><span style="display:flex;"><span>5 |     println!(&#34;a: {:?}\nb: {:?}&#34;, a, b);
</span></span><span style="display:flex;"><span>  |                                  ^ value borrowed here after move
</span></span></code></pre></div><p>This error message jumps the gun a bit, anticipating what we want to do and suggesting a way to proceed. We&rsquo;ll get to &ldquo;borrowing&rdquo; and the <code>Copy</code> trait later. For now, note the error on line 5, which was triggered because we tried to access <code>a</code> after a move.</p>
<p>It can sometimes be hard to spot a move. Consider what happens when we pass an argument to a function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sum</span>(vector: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// mutability, more on this later
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> item <span style="color:#66d9ef">in</span> vector {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">=</span> sum <span style="color:#f92672">+</span> item
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> sum(v); <span style="color:#75715e">// watch out, v was MOVED!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;sum: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This code compiles and prints the result <code>sum: 6</code> as expected, However, it&rsquo;s easy to ignore the implicit move that takes place when calling <code>sum</code>. Specifically, the value owned by <code>v</code> is <em>moved</em> to the <code>vector</code> parameter of the <code>sum</code> function.</p>
<p>If we were to use <code>v</code> after this move, the compiler would complain:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sum</span>(vector: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> item <span style="color:#66d9ef">in</span> vector {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">=</span> sum <span style="color:#f92672">+</span> item
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> sum(v);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;sum of </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, v, s); <span style="color:#75715e">// ERROR: v was MOVED!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>In fact, we get essentially the same error (and cheerfully helpful suggestion) as with the more obvious reassignment.</p>
<p>Yet another form of reassignment occurs when returning a value from a function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_series</span>(x: <span style="color:#66d9ef">i32</span>) -&gt; Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> vec![x, x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, x<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    result
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> series <span style="color:#f92672">=</span> create_series(<span style="color:#ae81ff">42</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;series: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, series);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Fortunately, this form of reassignment doesn&rsquo;t cause the same problems as the other two because when a function exits, its corresponding scope ends. There&rsquo;s no way to later access the old scope or its local variables. We do, however, retain access to return values.</p>


<h1 class="relative group">Copy 
    <div id="copy" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#copy" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>What if we wanted to re-use a variable after a reassignment? The previous section showed what happens when we try the following.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sum</span>(vector: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> item <span style="color:#66d9ef">in</span> vector {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">=</span> sum <span style="color:#f92672">+</span> item
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> sum(v);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;sum of </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, v, s); <span style="color:#75715e">// ERROR: v was MOVED!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>However, the following example compiles and runs just fine. Why can we use both <code>a</code> and <code>b</code> even though they&rsquo;ve been passed as arguments to <code>sum</code>?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sum</span>(left: <span style="color:#66d9ef">i32</span>, right: <span style="color:#66d9ef">i32</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    left <span style="color:#f92672">+</span> right
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> sum(a, b);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;this sum of </span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> and </span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> is </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, a, b, s); <span style="color:#75715e">// no error!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Instead of moving the values owned by <code>a</code> and <code>b</code> to the parameters of <code>sum</code>, the values are <em>copied</em>. A copy creates an exact duplicate of a value that implements the <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html" target="_blank"><code>Copy</code> trait</a>. Numerical values and several other inexpensive built-in Rust types support copy. Vectors do not.</p>
<p>The example with <code>Vec</code> fails to compile because <code>Vec</code> does not implement the <code>Copy</code> trait. The example with <code>i32</code> succeeds because this type supports copy.</p>
<p>This difference becomes obvious with user-defined types. Such types are created from a struct. For example, we can define a <code>Person</code> type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    age: <span style="color:#66d9ef">i8</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> Person { age: <span style="color:#ae81ff">42</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;alice: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, alice);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>At the top of the <code>Person</code> definition sits a <a href="https://doc.rust-lang.org/reference/procedural-macros.html" target="_blank">procedural macro</a>. Its purpose is to automatically generate code. In the case of <code>#[derive(Debug)]</code> the generated code makes it possible to use <code>Person</code> in <code>println!</code> output.</p>
<p>Structs do not implement <code>Copy</code> by default. Reassignment of a <code>Person</code> value leads to a move, not a copy, as can be seen below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    age: <span style="color:#66d9ef">i8</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> Person { age: <span style="color:#ae81ff">42</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bob <span style="color:#f92672">=</span> alice;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;alice: </span><span style="color:#e6db74">{:?}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">bob: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, alice, bob); <span style="color:#75715e">// ERROR: alice moved
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Once again the compiler throws the familiar error: &ldquo;value borrowed here after move.&rdquo;</p>
<p>We can, however, transform <code>Person</code> into a type that implements <code>Copy</code>. To do so, we can automatically derive the <code>Copy</code> trait just like the <code>Debug</code> trait was derived. For <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#whats-the-difference-between-copy-and-clone" target="_blank">reasons</a> beyond the scope of this tutorial, <code>Clone</code> must also be derived.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug,Clone,Copy)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    age: <span style="color:#66d9ef">i8</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> Person { age: <span style="color:#ae81ff">42</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bob <span style="color:#f92672">=</span> alice;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;alice: </span><span style="color:#e6db74">{:?}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">bob: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, alice, bob);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Compiling and running this code yields the expected output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>alice: Person { age: 42 }
</span></span><span style="display:flex;"><span>bob: Person { age: 42 }
</span></span></code></pre></div><p>This <code>Copy</code> fix works for values like <code>Person</code> that can be efficiently copied, but what about expensive values?</p>


<h1 class="relative group">Borrow 
    <div id="borrow" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#borrow" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>Many resources are too expensive in terms of time or memory be copied for every reassignment. In these cases, Rust offers the option to <em>borrow</em>.</p>
<p>Previously, we saw that a non-copyable value couldn&rsquo;t be reassigned. We can solve this problem by borrowing the value instead. To do so, we precede the assignee variable with the ampersand (<code>&amp;</code>) character.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span> <span style="color:#75715e">// no more copy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    age: <span style="color:#66d9ef">u8</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> Person { age: <span style="color:#ae81ff">8</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bob <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>alice; <span style="color:#75715e">// bob borrows alice
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;alice: </span><span style="color:#e6db74">{:?}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">bob: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, alice, bob);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Despite the lack of a <code>Copy</code> trait on <code>Person</code>, the code above compiles and gives the same output as before:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>alice: Person { age: 42 }
</span></span><span style="display:flex;"><span>bob: Person { age: 42 }
</span></span></code></pre></div><p>Similarly, non-copyable value can be passed as an argument to a function if it is borrowed. Notice the use of borrow notation (<code>&amp;</code>) in the signature for <code>sum</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sum</span>(vector: <span style="color:#66d9ef">&amp;</span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">i32</span> { <span style="color:#75715e">// borrow signature
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> item <span style="color:#66d9ef">in</span> vector {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">=</span> sum <span style="color:#f92672">+</span> item
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v_ref <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v;  <span style="color:#75715e">// v_ref borrows v
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> sum(v_ref);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;sum of </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, v_ref, s); <span style="color:#75715e">// no error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>The code above produces the expected result: <code>sum of [1, 2, 3]: 6</code>.</p>
<p>If assignment <em>always</em> creates an ownership relationship, it may be surprising that the above code works. After all, <code>v_ref</code>, a reference value, is not passed by reference, yet it can still be accessed within <code>println!</code>. The answer is that with one notable exception <a href="https://stackoverflow.com/questions/41413336" target="_blank">references themselves implement <code>Copy</code></a>. Although it may seem odd, the references in the examples so far are passed by value.</p>


<h1 class="relative group">Passing by Reference or Value 
    <div id="passing-by-reference-or-value" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#passing-by-reference-or-value" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>The preceding sections show how Rust lets us pass a value to a function either by reference or value. Here&rsquo;s a recap:</p>
<ol>
<li>If a value implements <code>Copy</code> and is not borrowed, it will be passed by value.</li>
<li>If a value implements <code>Copy</code> and is borrowed, it will be passed by reference.</li>
<li>If a value does not implement <code>Copy</code>, it must be borrowed and so will be passed by reference.</li>
<li>References implement <code>Copy</code> and so are passed by value. There is one exception, which is described later.</li>
</ol>
<p>Summarizing these rules in example form:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">pass_number_by_reference</span>(number: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">i8</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    number.is_negative()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">pass_number_by_value</span>(number: <span style="color:#66d9ef">i8</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    number.is_negative()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">pass_vec_by_reference</span>(vec: <span style="color:#66d9ef">&amp;</span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i8</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    vec.is_empty()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// numbers implement Copy, and so can be passed by value or reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> number <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// does not move number because of borrow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> is_negative_by_ref <span style="color:#f92672">=</span> pass_number_by_reference(<span style="color:#f92672">&amp;</span>number);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// moves number, which can never be used again
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> is_negative_by_value <span style="color:#f92672">=</span> pass_number_by_value(number);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// copy not implemented - must be passed by reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> vec <span style="color:#f92672">=</span> vec![];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// does not move vec
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> is_empty <span style="color:#f92672">=</span> pass_vec_by_reference(<span style="color:#f92672">&amp;</span>vec);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;is_negative_by_value: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, is_negative_by_value);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;is_negative_by_ref: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, is_negative_by_ref);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;vec </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> is_empty: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, vec, is_empty);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

<h1 class="relative group">Borrowing and String Literals 
    <div id="borrowing-and-string-literals" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#borrowing-and-string-literals" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>String manipulation is an important capability in any language. In Rust, string literals are borrowed references. For example, consider:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">byte_length</span>(string: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">usize</span> {
</span></span><span style="display:flex;"><span>    string.bytes().len()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;🦀&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> length <span style="color:#f92672">=</span> byte_length(string);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Bytes in </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">{}</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, string, length);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The compiler recognizes the value owned by <code>string</code> as the borrowed reference type <code>&amp;str</code> (reference to <code>str</code>).  Using <code>string</code> after calling <code>byte_length</code> in <code>println!</code> is allowed because the reference itself is copied into the <code>string</code> parameter of <code>byte_length</code>.</p>


<h1 class="relative group">Returning a Borrowed Value 
    <div id="returning-a-borrowed-value" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#returning-a-borrowed-value" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>Sometimes we&rsquo;ll want a function to return a borrowed value. For example, we might want to return the longer of two strings in terms of byte length. We might try the following.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Errors!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">longest</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> x.bytes().len() <span style="color:#f92672">&gt;</span> y.bytes().len() {
</span></span><span style="display:flex;"><span>        x
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        y
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Alice&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bob <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Bob&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, longest(alice, bob));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, we&rsquo;d be greeted with a cryptic looking error referring to something called a &ldquo;lifetime&rdquo;.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</span></span><span style="display:flex;"><span>  |                                 ^ expected lifetime parameter
</span></span><span style="display:flex;"><span>  |
</span></span><span style="display:flex;"><span>  = help: this function&#39;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
</span></span></code></pre></div>

<h1 class="relative group">Lifetimes 
    <div id="lifetimes" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#lifetimes" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>A <em>lifetime</em> is the scope within which a borrowed reference is valid. The Rust compiler is smart enough to infer lifetimes in many cases, meaning that we don&rsquo;t need to explicitly write them. This cuts both ways, though. When the compiler requires a lifetime, the concept seems alien.</p>
<p>Let&rsquo;s rewrite a previous example with an explicit, but unnecessary lifetime. This is accomplished by adding a <em>lifetime parameter</em>. A lifetime parameter can be added anywhere a borrowed reference appears. Like type parameters (aka &ldquo;generics&rdquo;), a lifetime parameter must be brought into scope before it can be used. We do this by placing the parameter into the angle brackets (<code>&lt;</code> and <code>&gt;</code>) following the name of the function. This is also where type parameter declarations go.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">byte_length</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(string: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">usize</span> { <span style="color:#75715e">// unnecessary lifetime
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    string.bytes().len()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;🦀&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> length <span style="color:#f92672">=</span> byte_length(string);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Bytes in </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">{}</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, string, length);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This example compiles and runs just like before. There are only two differences: (1) the lifetime parameter declaration <code>&lt;'a&gt;</code> after <code>byte_length</code>; and (2) the lifetime parameter <code>'a</code> immediately following the ampersand in the parameter <code>string</code>&rsquo;s type definition. The name of a lifetime parameter (e.g., <code>'a</code>) begins with an apostrophe symbol (<code>'</code>) and ends with one or more characters - typically just one. The content within angle brackets brings the lifetime parameter <code>'a</code> into scope.</p>
<p>The previous section presented this failing example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">longest</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> {     <span style="color:#75715e">// error: expected lifetime parameter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> x.bytes().len() <span style="color:#f92672">&gt;</span> y.bytes().len() {
</span></span><span style="display:flex;"><span>        x
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        y
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Alice&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bob <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Bob&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, longest(alice, bob));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This won&rsquo;t compile because we have not yet constrained the lifetime of the return value. Without bounds on this value, there is no way to exclude cases in which the <code>longest</code> function returns a reference to a dropped value. Adding  a constraint in the form of a lifetime parameter excludes those cases. The idea is analogous to a type parameter that excludes cases in which a variable holds a value of incompatible type.</p>
<p>With this idea in mind, we update the example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">longest</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> x.bytes().len() <span style="color:#f92672">&gt;</span> y.bytes().len() {
</span></span><span style="display:flex;"><span>        x
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        y
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Alice&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bob <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Bob&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, longest(alice, bob));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The change allows the compiler to determine that the lifetime (valid scope) of the value whose borrowed reference it returns matches the lifetime of the parameters <code>x</code> and <code>y</code>. In other words, there is no way for the <code>longest</code> function to return a reference to a dropped value.</p>
<p>It&rsquo;s tempting to think of lifetime parameters as a way to make a reference &ldquo;live longer.&rdquo; A better approach is to consider the similarity between type parameters and lifetime parameters. A type parameter constrains the range of possible types for a value owned by a variable. Likewise, a lifetime parameter constrains the range of possible lifetimes (valid scopes) for a value owned by a variable.</p>


<h1 class="relative group">Lifetimes and Structs 
    <div id="lifetimes-and-structs" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#lifetimes-and-structs" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>Function parameters aren&rsquo;t the only context in which lifetimes appear. When a struct declares a member with a reference type, the lifetime of that member must also be declared. The example below won&rsquo;t compile.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> <span style="color:#75715e">// error: expected lifetime parameter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> Person { name: <span style="color:#e6db74">&#34;Alice&#34;</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;alice: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, alice);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here, the compiler can&rsquo;t rule out cases in which the <code>name</code> member is dropped before its enclosing <code>Person</code> instance. We can correct this problem by adding a lifetime parameter <code>'a</code>. In doing so, we notify the compiler that <code>name</code> will live at least as long as its parent.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    name: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> Person { name: <span style="color:#e6db74">&#34;Alice&#34;</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;alice: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, alice);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

<h1 class="relative group">Mutability 
    <div id="mutability" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#mutability" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>So far we&rsquo;ve only considered values that never change. But writing real software requires state changes — mainly through changes to the state of values. This capability of changing the state of a value is known as <em>mutability</em>.</p>
<p>Mutability may seem unrelated to ownership, but the two concepts are tightly coupled. In particular, mutability constrains your ability to borrow references.</p>
<p>In Rust, variables own immutable values by default. We can override this behavior by preceding a variable with the <code>mut</code> keyword.</p>
<p>For example, we&rsquo;re unable to add members to a <code>Vec</code> by default:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> numbers <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    numbers.push(<span style="color:#ae81ff">4</span>); <span style="color:#75715e">// ERROR: cannot borrow as mutable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;numbers: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, numbers);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Making the owner mutable solves this problem.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> numbers <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    numbers.push(<span style="color:#ae81ff">4</span>);  <span style="color:#75715e">// mutable Vec supports push
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;numbers: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, numbers);  <span style="color:#75715e">// numbers: [1, 2, 3, 4]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div>

<h1 class="relative group">MARSAW: Multiple Active Readers or Single Active Writer 
    <div id="marsaw-multiple-active-readers-or-single-active-writer" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#marsaw-multiple-active-readers-or-single-active-writer" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>Mutability constrains our ability to borrow references. The book <em><a href="https://www.oreilly.com/library/view/programming-rust/9781491927274/" target="_blank">Programming Rust</a></em> refers to the high-level concept as <em>multiple readers or single writer</em>.</p>
<p><em><a href="https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html#the-rules" target="_blank">The Rust Programming Language</a></em> describes the same principle like so:</p>
<blockquote>
<p>&hellip; you may have one or the other of these two kinds of borrows, but not both at the same time:</p>
<ul>
<li>one or more references (<code>&amp;T</code>) to a resource,</li>
<li>exactly one mutable reference (<code>&amp;mut T</code>).</li>
</ul>
</blockquote>
<p>Neither description, however, quite hits the mark. First, the rule applies to both borrowed references and <em>owners</em>. Second, the rule only applies when <em>active</em> readers and writers are involved. As such, it might be more instructive to recast the rule as: &ldquo;multiple active readers or single active writer&rdquo; (MARSAW).</p>
<p>The term &ldquo;active&rdquo; deserves some explanation. Until a writer&rsquo;s mutable API is used, it&rsquo;s inactive. After mutation, the writer stays active for the duration of its lifetime. A reader borrowed before the activation of a writer will become active on the first use of the owner&rsquo;s immutable API.</p>
<p>Let&rsquo;s look at some examples to make these ideas more concrete.</p>
<p>One <em>inactive</em> writer and one <em>inactive</em> reader can co-exist within the same scope, as demonstrated below. You&rsquo;ll notice warnings about unused variables, but no errors.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];   <span style="color:#75715e">// inactive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;           <span style="color:#75715e">// inactive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>We can read without triggering an error, although we&rsquo;ll receive an additional warning about unneeded mutability on <code>writer</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;len: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, reader.len()); <span style="color:#75715e">// no error, inactive writer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Likewise, we write without triggering a compiler error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    writer.push(<span style="color:#ae81ff">4</span>);  <span style="color:#75715e">// no error, inactive reader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>We can take this further with sequential read-write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;len: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, reader.len()); <span style="color:#75715e">// no error, inactive writer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    writer.push(<span style="color:#ae81ff">4</span>);                    <span style="color:#75715e">// no error, inactive reader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>We can exercise <code>writer</code>&rsquo;s immutable API, then read without producing an error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    writer.len();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;len: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, reader.len()); <span style="color:#75715e">// no error: inactive reader and writer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>What we can&rsquo;t do is activate <code>writer</code> then use <code>reader</code>. The following code produces an error because the <code>println!</code> statement generates an active reader, which when paired with the active writer is not allowed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    writer.push(<span style="color:#ae81ff">4</span>);                    <span style="color:#75715e">// error: cannot borrow `writer` as mutable because it is also borrowed as immutable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;len: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, reader.len());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The error message explains the situation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>3 |     let reader = &amp;writer;
</span></span><span style="display:flex;"><span>  |                  ------- immutable borrow occurs here
</span></span><span style="display:flex;"><span>4 | 
</span></span><span style="display:flex;"><span>5 |     writer.push(4);                    // active writer, inactive reader
</span></span><span style="display:flex;"><span>  |     ^^^^^^^^^^^^^^ mutable borrow occurs here
</span></span><span style="display:flex;"><span>6 |     
</span></span><span style="display:flex;"><span>7 |     println!(&#34;len: {}&#34;, reader.len()); // error: cannot borrow `writer` as mutable because it is also borrowed as immutable
</span></span><span style="display:flex;"><span>  |                         ------ immutable borrow later used here
</span></span></code></pre></div><p>We can eliminate the error by pulling the borrow down after the call to <code>push</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    writer.push(<span style="color:#ae81ff">4</span>); 
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;len: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, reader.len()); <span style="color:#75715e">// no error, reader is not active because it was borrowed _after_ last writer mutation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Even though a variable might be declared as <code>mut</code>, it can nevertheless be used to read. Note that <code>writer.iter</code> triggers an implicit immutable borrow. This does not violate MARSAW, however, because the borrow occurs after the last mutation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    writer.push(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> number <span style="color:#66d9ef">in</span> writer.iter() {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;number: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, number); <span style="color:#75715e">// no error, implicit borrow occurs after writer mutation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Implicit borrowing can nevertheless lead to a MARSAW violation if coupled to a write. The following code won&rsquo;t compile because the <code>iter</code> method implicitly borrows an immutable reference, creating a simultaneously active reader and writer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> number <span style="color:#66d9ef">in</span> writer.iter() {
</span></span><span style="display:flex;"><span>        writer.push(number <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// ERROR: cannot borrow `writer` as mutable because it is also borrowed as immutable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The error (below) lets us know where borrowing occurs. Used together with the MARSAW principle, we can identify the problem&rsquo;s source as an <em>active</em> reader and writer operating simultaneously.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>4 |     for number in writer.iter() {
</span></span><span style="display:flex;"><span>  |                   -------------
</span></span><span style="display:flex;"><span>  |                   |
</span></span><span style="display:flex;"><span>  |                   immutable borrow occurs here
</span></span><span style="display:flex;"><span>  |                   immutable borrow later used here
</span></span><span style="display:flex;"><span>5 |         writer.push(number + 2); // ERROR: cannot borrow `writer` as mutable because it is also borrowed as immutable
</span></span><span style="display:flex;"><span>  |         ^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
</span></span></code></pre></div>

<h1 class="relative group">Conclusion 
    <div id="conclusion" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#conclusion" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>Ownership permeates Rust, so it&rsquo;s critical to understand it early in your study of the language. This guide offers some simple examples illustrating how ownership works. Key points can be summarized as:</p>
<ol>
<li>Assignment always binds a value to a variable, which becomes the value&rsquo;s sole owner.</li>
<li>Passing and returning by value both count as assignment.</li>
<li>A value will always be dropped by the time its owner goes out of scope.</li>
<li>Reassignment of a value results in a move, or change of ownership.</li>
<li>After a move, the former assignee can never be used again.</li>
<li>A reference can be borrowed through reassignment by preceding its owner with the ampersand symbol (<code>&amp;</code>).</li>
<li>A borrowed reference may not live longer than the underlying value.</li>
<li>A lifetime parameter, written with an apostrophe character (<code>'</code>) followed by at least one letter, represents the scope of a borrowed reference.</li>
<li>A lifetime parameter identifies two references as having the same minimum scope.</li>
<li>The MARSAW principle allows for either multiple readers or a single writer to be active at the same time, but not both. Owners and references both count.</li>
</ol>

          
          
          
        </div>
        
        

        
        

          
      </div>
     
      
      
        
        
          
          
        
      <script>
        var oid = "views_posts\/2020-01-27-rust-ownership-by-example.md"
        var oid_likes = "likes_posts\/2020-01-27-rust-ownership-by-example.md"
      </script>
      
      
      <script type="text/javascript" src="/js/page.min.0860cf4e04fa2d72cc33ddba263083464d48f67de06114529043cb4623319efed4f484fd7f1730df5abea0e2da6f3538855634081d02f2d6e920b956f063e823.js" integrity="sha512-CGDPTgT6LXLMM926JjCDRk1I9n3gYRRSkEPLRiMxnv7U9IT9fxcw31q&#43;oOLabzU4hVY0CB0C8tbpILlW8GPoIw=="></script>
      
  
    </section>
  <footer class="pt-8 max-w-prose print:hidden">

    
  
    
    
    
    <div class="pt-8">
      <hr class="border-dotted border-neutral-300 dark:border-neutral-600" />
      <div class="flex justify-between pt-3">
        <span>
          
            <a class="flex group mr-3" href="/articles/2020/01/20/rust-for-cheminformatics/">
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >Rust for Cheminformatics</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2020-01-20T18:00:00&#43;00:00">January 20, 2020</time>
                  
                </span>
              </span>
            </a>
          
        </span>
        <span>
          
            <a class="flex text-right group ml-3" href="/articles/2020/02/03/graphs-in-rust-an-introduction-to-petgraph/">
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >Graphs in Rust: An Introduction to Petgraph</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2020-02-03T14:00:00&#43;00:00">February 3, 2020</time>
                  
                </span>
              </span>
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
            </a>
          
        </span>
      </div>
    </div>
  


    
  </footer>
</article>

      <div id="top-scroller" class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0">
  <a href="#the-top"
    class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400"
    aria-label="Scroll to top" title="Scroll to top">
    &uarr;
  </a>
</div>
    </main><footer id="site-footer" class="py-10 print:hidden">
  
  
    
  
  <div class="flex items-center justify-between">

    
    
    <p class="text-sm text-neutral-500 dark:text-neutral-400">
      &copy;
      2024
      
    </p>
    

    
    
    <p class="text-xs text-neutral-500 dark:text-neutral-400">
      
      
      Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> &amp; <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://blowfish.page/" target="_blank" rel="noopener noreferrer">Blowfish</a>
    </p>
    

  </div>
  <script>
    
    mediumZoom(document.querySelectorAll("img:not(.nozoom)"), {
      margin: 24,
      background: 'rgba(0,0,0,0.5)',
      scrollOffset: 0,
    })
    
  </script>
  
  
  <script type="text/javascript" src="/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js" integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh&#43;sCQ0E53ghYrxgYqw&#43;0GCRyIEpA=="></script>
  
  
</footer>
<div
  id="search-wrapper"
  class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]"
  data-url="http://localhost:1313/"
  style="z-index:500"
>
  <div
    id="search-modal"
    class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"
  >
    <header class="relative z-10 flex items-center justify-between flex-none px-2">
      <form class="flex items-center flex-auto min-w-0">
        <div class="flex items-center justify-center w-8 h-8 text-neutral-400">
          

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


        </div>
        <input
          type="search"
          id="search-query"
          class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent"
          placeholder="Search"
          tabindex="0"
        />
      </form>
      <button
        id="close-search-button"
        class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        title="Close (Esc)"
      >
        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>


      </button>
    </header>
    <section class="flex-auto px-2 overflow-auto">
      <ul id="search-results">
        
      </ul>
    </section>
  </div>
</div>

  </div>
</body>

</html>
