<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Rust Ownership by Example | Depth-First</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="A deep dive for beginners into Rust&rsquo;s most important big idea.">
    <meta name="generator" content="Hugo 0.139.4">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/articles/2020/01/27/rust-ownership-by-example/">
    

    <meta property="og:url" content="http://localhost:1313/articles/2020/01/27/rust-ownership-by-example/">
  <meta property="og:site_name" content="Depth-First">
  <meta property="og:title" content="Rust Ownership by Example">
  <meta property="og:description" content="A deep dive for beginners into Rust’s most important big idea.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2020-01-27T14:00:00+00:00">
    <meta property="article:modified_time" content="2020-01-27T14:00:00+00:00">

  <meta itemprop="name" content="Rust Ownership by Example">
  <meta itemprop="description" content="A deep dive for beginners into Rust’s most important big idea.">
  <meta itemprop="datePublished" content="2020-01-27T14:00:00+00:00">
  <meta itemprop="dateModified" content="2020-01-27T14:00:00+00:00">
  <meta itemprop="wordCount" content="4094">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Rust Ownership by Example">
  <meta name="twitter:description" content="A deep dive for beginners into Rust’s most important big idea.">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Depth-First
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Articles
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Rust Ownership by Example</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2020-01-27T14:00:00Z">January 27, 2020</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p><a href="https://www.rust-lang.org">Rust</a> is a safe systems programming language. Although C and C++ are systems languages, they&rsquo;re not safe. Specifically, Rust is a &ldquo;<a href="http://www.pl-enthusiast.net/2014/08/05/type-safety/">type safe language</a>&rdquo;, meaning that the compiler ensures that every program has well-defined behavior. Although other languages make the same guarantee, Rust does so without a garbage collector, runtime, or manual memory management.</p>
<p>Key to Rust&rsquo;s safety guarantee, and its most unusual feature, is the concept of <em>ownership</em>. When new Rust programmers run into trouble, the problem often boils down to ownership. Master ownership, and Rust will make a lot of sense. Ignore ownership, and you&rsquo;ll fight the compiler to accomplish even the simplest tasks.</p>
<p>This beginner Rust tutorial, unlike most others, features ownership front-and-center. Short examples highlight the practical consequences of ownership. I&rsquo;m no Rust expert. However, I have tried to choose examples that speak for themselves, and descriptions that jibe with reputable sources when possible.</p>
<h1 id="getting-started">Getting Started</h1>
<p>Running sample code and experimentation are very helpful for learning Rust. The easiest way to do that is to copy and paste the examples here into the <a href="https://play.rust-lang.org">Rust Playground</a> web application. If you&rsquo;d rather compile and run code on your own machine, the easiest way to do that is <a href="https://rustup.rs">rustup</a>.</p>
<h1 id="ownership-begins-with-assignment">Ownership Begins with Assignment</h1>
<p>Like other languages, Rust uses the equals symbol (<code>=</code>) to assign a value to a variable. The variable then serves as a handle for later use.</p>
<p>The following program assigns the literal value <code>42</code> to the variable <code>x</code>, then prints the value of <code>x</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;x: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But Rust takes assignment one step further. The assignee (<code>x</code>) becomes the value&rsquo;s sole owner. There are no exceptions. The tight coupling between assignment and ownership sets the stage for many of Rust&rsquo;s unique capabilities.</p>
<h1 id="ownership-ends-with-scope">Ownership Ends with Scope</h1>
<p>When a variable goes out of scope, its associated value, if any, is <em>dropped</em>. A dropped value can never be used again because the resources it uses are immediately freed.</p>
<p>This rule makes it easy to reason about the liveness of values. For as long as a variable remains in scope, the value it owns will never be dropped. By the time the owner goes out of scope, its value will have been dropped. A value can be dropped before the end of a scope if the compiler determines that the owner is no longer used within the scope.</p>
<p>We can see this rule in action by assigning a variable within an anonymous scope created by the left and right curly brace characters (<code>{</code> and <code>}</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;x: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;x: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x); <span style="color:#75715e">// ERROR: x not in scope
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>The compiler rejects this code, informing us that the variable used in the second <code>println!</code> (<code>x</code>) is not in scope.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>8 |     println!(&#34;x: {}&#34;, x);
</span></span><span style="display:flex;"><span>  |                       ^ not found in this scope
</span></span></code></pre></div><p>Most languages would not allow you to use <code>x</code> outside of its local scope, either. But in Rust, this limitation goes further. When the anonymous scope ends, the value owned by <code>x</code> (<code>42</code>) is dropped.</p>
<p>A slightly more advanced example proves the order of events. Some explanation might be useful. We define a custom type <code>DropMe</code> that implements the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code> trait</a> and its associated <code>drop</code> method. <code>drop</code> is called before an instance is dropped, printing a farewell message before digital oblivion. The remaining syntax will be explained later.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">DropMe</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Drop <span style="color:#66d9ef">for</span> DropMe {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">drop</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Dropping!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Begin outer scope.&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;Begin inner scope.&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> DropMe;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;x: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;End outer scope.&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The program output demonstrates that the value owned by <code>x</code> is dropped when the variable goes out of scope:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>Begin outer scope.
</span></span><span style="display:flex;"><span>Begin inner scope.
</span></span><span style="display:flex;"><span>x: DropMe
</span></span><span style="display:flex;"><span>Dropping!
</span></span><span style="display:flex;"><span>End outer scope.
</span></span></code></pre></div><h1 id="reassignment-moves-ownership">Reassignment Moves Ownership</h1>
<p>If assignment creates an ownership relationship, what about <em>reassignment</em>? Imagine we want to reassign the value owned by <code>a</code> to a new variable, <code>b</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]; <span style="color:#75715e">// a growable array literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> a;             <span style="color:#75715e">// move: `a` can no longer be used
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;b: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, b);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vectors</a> (aka <code>Vec</code>) are Rust&rsquo;s growable array type. Vector literals are created with the <code>vec!</code> macro.</p>
<p>The above code compiles and runs, printing the result <code>b: [1, 2, 3]</code>. Following the rule that assignment creates an ownership relationship, we expect <code>b</code> to be the new owner. Given that a value can have only one owner, we further expect <code>a</code> to be uninitialized and therefore unusable. Both expectations are correct.</p>
<p>Reassignment of ownership (as in <code>let b = a</code>) is known as a <em>move</em>. A move causes the former assignee to become uninitialized and therefore not usable in the future.</p>
<p>We can confirm this by compiling:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;a: </span><span style="color:#e6db74">{:?}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">b: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, a, b); <span style="color:#75715e">// error: borrow of moved value: `a`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>The compiler detects our attempt to reuse the now uninitialized <code>a</code> and complains:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>2 |     let a = vec![1,2,3];
</span></span><span style="display:flex;"><span>  |         - move occurs because `a` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait
</span></span><span style="display:flex;"><span>3 |     let b = a;
</span></span><span style="display:flex;"><span>  |             - value moved here
</span></span><span style="display:flex;"><span>4 | 
</span></span><span style="display:flex;"><span>5 |     println!(&#34;a: {:?}\nb: {:?}&#34;, a, b);
</span></span><span style="display:flex;"><span>  |                                  ^ value borrowed here after move
</span></span></code></pre></div><p>This error message jumps the gun a bit, anticipating what we want to do and suggesting a way to proceed. We&rsquo;ll get to &ldquo;borrowing&rdquo; and the <code>Copy</code> trait later. For now, note the error on line 5, which was triggered because we tried to access <code>a</code> after a move.</p>
<p>It can sometimes be hard to spot a move. Consider what happens when we pass an argument to a function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sum</span>(vector: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// mutability, more on this later
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> item <span style="color:#66d9ef">in</span> vector {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">=</span> sum <span style="color:#f92672">+</span> item
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> sum(v); <span style="color:#75715e">// watch out, v was MOVED!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;sum: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This code compiles and prints the result <code>sum: 6</code> as expected, However, it&rsquo;s easy to ignore the implicit move that takes place when calling <code>sum</code>. Specifically, the value owned by <code>v</code> is <em>moved</em> to the <code>vector</code> parameter of the <code>sum</code> function.</p>
<p>If we were to use <code>v</code> after this move, the compiler would complain:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sum</span>(vector: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> item <span style="color:#66d9ef">in</span> vector {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">=</span> sum <span style="color:#f92672">+</span> item
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> sum(v);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;sum of </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, v, s); <span style="color:#75715e">// ERROR: v was MOVED!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>In fact, we get essentially the same error (and cheerfully helpful suggestion) as with the more obvious reassignment.</p>
<p>Yet another form of reassignment occurs when returning a value from a function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_series</span>(x: <span style="color:#66d9ef">i32</span>) -&gt; Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> vec![x, x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, x<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    result
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> series <span style="color:#f92672">=</span> create_series(<span style="color:#ae81ff">42</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;series: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, series);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Fortunately, this form of reassignment doesn&rsquo;t cause the same problems as the other two because when a function exits, its corresponding scope ends. There&rsquo;s no way to later access the old scope or its local variables. We do, however, retain access to return values.</p>
<h1 id="copy">Copy</h1>
<p>What if we wanted to re-use a variable after a reassignment? The previous section showed what happens when we try the following.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sum</span>(vector: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> item <span style="color:#66d9ef">in</span> vector {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">=</span> sum <span style="color:#f92672">+</span> item
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> sum(v);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;sum of </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, v, s); <span style="color:#75715e">// ERROR: v was MOVED!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>However, the following example compiles and runs just fine. Why can we use both <code>a</code> and <code>b</code> even though they&rsquo;ve been passed as arguments to <code>sum</code>?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sum</span>(left: <span style="color:#66d9ef">i32</span>, right: <span style="color:#66d9ef">i32</span>) -&gt; <span style="color:#66d9ef">i32</span> {
</span></span><span style="display:flex;"><span>    left <span style="color:#f92672">+</span> right
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> sum(a, b);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;this sum of </span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> and </span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> is </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, a, b, s); <span style="color:#75715e">// no error!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Instead of moving the values owned by <code>a</code> and <code>b</code> to the parameters of <code>sum</code>, the values are <em>copied</em>. A copy creates an exact duplicate of a value that implements the <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code> trait</a>. Numerical values and several other inexpensive built-in Rust types support copy. Vectors do not.</p>
<p>The example with <code>Vec</code> fails to compile because <code>Vec</code> does not implement the <code>Copy</code> trait. The example with <code>i32</code> succeeds because this type supports copy.</p>
<p>This difference becomes obvious with user-defined types. Such types are created from a struct. For example, we can define a <code>Person</code> type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    age: <span style="color:#66d9ef">i8</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> Person { age: <span style="color:#ae81ff">42</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;alice: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, alice);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>At the top of the <code>Person</code> definition sits a <a href="https://doc.rust-lang.org/reference/procedural-macros.html">procedural macro</a>. Its purpose is to automatically generate code. In the case of <code>#[derive(Debug)]</code> the generated code makes it possible to use <code>Person</code> in <code>println!</code> output.</p>
<p>Structs do not implement <code>Copy</code> by default. Reassignment of a <code>Person</code> value leads to a move, not a copy, as can be seen below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    age: <span style="color:#66d9ef">i8</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> Person { age: <span style="color:#ae81ff">42</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bob <span style="color:#f92672">=</span> alice;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;alice: </span><span style="color:#e6db74">{:?}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">bob: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, alice, bob); <span style="color:#75715e">// ERROR: alice moved
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Once again the compiler throws the familiar error: &ldquo;value borrowed here after move.&rdquo;</p>
<p>We can, however, transform <code>Person</code> into a type that implements <code>Copy</code>. To do so, we can automatically derive the <code>Copy</code> trait just like the <code>Debug</code> trait was derived. For <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#whats-the-difference-between-copy-and-clone">reasons</a> beyond the scope of this tutorial, <code>Clone</code> must also be derived.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug,Clone,Copy)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    age: <span style="color:#66d9ef">i8</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> Person { age: <span style="color:#ae81ff">42</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bob <span style="color:#f92672">=</span> alice;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;alice: </span><span style="color:#e6db74">{:?}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">bob: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, alice, bob);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Compiling and running this code yields the expected output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>alice: Person { age: 42 }
</span></span><span style="display:flex;"><span>bob: Person { age: 42 }
</span></span></code></pre></div><p>This <code>Copy</code> fix works for values like <code>Person</code> that can be efficiently copied, but what about expensive values?</p>
<h1 id="borrow">Borrow</h1>
<p>Many resources are too expensive in terms of time or memory be copied for every reassignment. In these cases, Rust offers the option to <em>borrow</em>.</p>
<p>Previously, we saw that a non-copyable value couldn&rsquo;t be reassigned. We can solve this problem by borrowing the value instead. To do so, we precede the assignee variable with the ampersand (<code>&amp;</code>) character.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span> <span style="color:#75715e">// no more copy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    age: <span style="color:#66d9ef">u8</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> Person { age: <span style="color:#ae81ff">8</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bob <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>alice; <span style="color:#75715e">// bob borrows alice
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;alice: </span><span style="color:#e6db74">{:?}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">bob: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, alice, bob);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Despite the lack of a <code>Copy</code> trait on <code>Person</code>, the code above compiles and gives the same output as before:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>alice: Person { age: 42 }
</span></span><span style="display:flex;"><span>bob: Person { age: 42 }
</span></span></code></pre></div><p>Similarly, non-copyable value can be passed as an argument to a function if it is borrowed. Notice the use of borrow notation (<code>&amp;</code>) in the signature for <code>sum</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sum</span>(vector: <span style="color:#66d9ef">&amp;</span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">i32</span> { <span style="color:#75715e">// borrow signature
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> item <span style="color:#66d9ef">in</span> vector {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">=</span> sum <span style="color:#f92672">+</span> item
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v_ref <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v;  <span style="color:#75715e">// v_ref borrows v
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> sum(v_ref);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;sum of </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, v_ref, s); <span style="color:#75715e">// no error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>The code above produces the expected result: <code>sum of [1, 2, 3]: 6</code>.</p>
<p>If assignment <em>always</em> creates an ownership relationship, it may be surprising that the above code works. After all, <code>v_ref</code>, a reference value, is not passed by reference, yet it can still be accessed within <code>println!</code>. The answer is that with one notable exception <a href="https://stackoverflow.com/questions/41413336">references themselves implement <code>Copy</code></a>. Although it may seem odd, the references in the examples so far are passed by value.</p>
<h1 id="passing-by-reference-or-value">Passing by Reference or Value</h1>
<p>The preceding sections show how Rust lets us pass a value to a function either by reference or value. Here&rsquo;s a recap:</p>
<ol>
<li>If a value implements <code>Copy</code> and is not borrowed, it will be passed by value.</li>
<li>If a value implements <code>Copy</code> and is borrowed, it will be passed by reference.</li>
<li>If a value does not implement <code>Copy</code>, it must be borrowed and so will be passed by reference.</li>
<li>References implement <code>Copy</code> and so are passed by value. There is one exception, which is described later.</li>
</ol>
<p>Summarizing these rules in example form:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">pass_number_by_reference</span>(number: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">i8</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    number.is_negative()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">pass_number_by_value</span>(number: <span style="color:#66d9ef">i8</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    number.is_negative()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">pass_vec_by_reference</span>(vec: <span style="color:#66d9ef">&amp;</span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i8</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    vec.is_empty()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// numbers implement Copy, and so can be passed by value or reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> number <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// does not move number because of borrow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> is_negative_by_ref <span style="color:#f92672">=</span> pass_number_by_reference(<span style="color:#f92672">&amp;</span>number);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// moves number, which can never be used again
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> is_negative_by_value <span style="color:#f92672">=</span> pass_number_by_value(number);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// copy not implemented - must be passed by reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> vec <span style="color:#f92672">=</span> vec![];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// does not move vec
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> is_empty <span style="color:#f92672">=</span> pass_vec_by_reference(<span style="color:#f92672">&amp;</span>vec);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;is_negative_by_value: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, is_negative_by_value);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;is_negative_by_ref: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, is_negative_by_ref);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;vec </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> is_empty: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, vec, is_empty);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="borrowing-and-string-literals">Borrowing and String Literals</h1>
<p>String manipulation is an important capability in any language. In Rust, string literals are borrowed references. For example, consider:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">byte_length</span>(string: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">usize</span> {
</span></span><span style="display:flex;"><span>    string.bytes().len()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;🦀&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> length <span style="color:#f92672">=</span> byte_length(string);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Bytes in </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">{}</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, string, length);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The compiler recognizes the value owned by <code>string</code> as the borrowed reference type <code>&amp;str</code> (reference to <code>str</code>).  Using <code>string</code> after calling <code>byte_length</code> in <code>println!</code> is allowed because the reference itself is copied into the <code>string</code> parameter of <code>byte_length</code>.</p>
<h1 id="returning-a-borrowed-value">Returning a Borrowed Value</h1>
<p>Sometimes we&rsquo;ll want a function to return a borrowed value. For example, we might want to return the longer of two strings in terms of byte length. We might try the following.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Errors!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">longest</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> x.bytes().len() <span style="color:#f92672">&gt;</span> y.bytes().len() {
</span></span><span style="display:flex;"><span>        x
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        y
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Alice&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bob <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Bob&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, longest(alice, bob));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, we&rsquo;d be greeted with a cryptic looking error referring to something called a &ldquo;lifetime&rdquo;.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</span></span><span style="display:flex;"><span>  |                                 ^ expected lifetime parameter
</span></span><span style="display:flex;"><span>  |
</span></span><span style="display:flex;"><span>  = help: this function&#39;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
</span></span></code></pre></div><h1 id="lifetimes">Lifetimes</h1>
<p>A <em>lifetime</em> is the scope within which a borrowed reference is valid. The Rust compiler is smart enough to infer lifetimes in many cases, meaning that we don&rsquo;t need to explicitly write them. This cuts both ways, though. When the compiler requires a lifetime, the concept seems alien.</p>
<p>Let&rsquo;s rewrite a previous example with an explicit, but unnecessary lifetime. This is accomplished by adding a <em>lifetime parameter</em>. A lifetime parameter can be added anywhere a borrowed reference appears. Like type parameters (aka &ldquo;generics&rdquo;), a lifetime parameter must be brought into scope before it can be used. We do this by placing the parameter into the angle brackets (<code>&lt;</code> and <code>&gt;</code>) following the name of the function. This is also where type parameter declarations go.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">byte_length</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(string: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">usize</span> { <span style="color:#75715e">// unnecessary lifetime
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    string.bytes().len()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;🦀&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> length <span style="color:#f92672">=</span> byte_length(string);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Bytes in </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">{}</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, string, length);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This example compiles and runs just like before. There are only two differences: (1) the lifetime parameter declaration <code>&lt;'a&gt;</code> after <code>byte_length</code>; and (2) the lifetime parameter <code>'a</code> immediately following the ampersand in the parameter <code>string</code>&rsquo;s type definition. The name of a lifetime parameter (e.g., <code>'a</code>) begins with an apostrophe symbol (<code>'</code>) and ends with one or more characters - typically just one. The content within angle brackets brings the lifetime parameter <code>'a</code> into scope.</p>
<p>The previous section presented this failing example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">longest</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> {     <span style="color:#75715e">// error: expected lifetime parameter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> x.bytes().len() <span style="color:#f92672">&gt;</span> y.bytes().len() {
</span></span><span style="display:flex;"><span>        x
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        y
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Alice&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bob <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Bob&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, longest(alice, bob));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This won&rsquo;t compile because we have not yet constrained the lifetime of the return value. Without bounds on this value, there is no way to exclude cases in which the <code>longest</code> function returns a reference to a dropped value. Adding  a constraint in the form of a lifetime parameter excludes those cases. The idea is analogous to a type parameter that excludes cases in which a variable holds a value of incompatible type.</p>
<p>With this idea in mind, we update the example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">longest</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(x: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>, y: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> x.bytes().len() <span style="color:#f92672">&gt;</span> y.bytes().len() {
</span></span><span style="display:flex;"><span>        x
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        y
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Alice&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bob <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Bob&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, longest(alice, bob));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The change allows the compiler to determine that the lifetime (valid scope) of the value whose borrowed reference it returns matches the lifetime of the parameters <code>x</code> and <code>y</code>. In other words, there is no way for the <code>longest</code> function to return a reference to a dropped value.</p>
<p>It&rsquo;s tempting to think of lifetime parameters as a way to make a reference &ldquo;live longer.&rdquo; A better approach is to consider the similarity between type parameters and lifetime parameters. A type parameter constrains the range of possible types for a value owned by a variable. Likewise, a lifetime parameter constrains the range of possible lifetimes (valid scopes) for a value owned by a variable.</p>
<h1 id="lifetimes-and-structs">Lifetimes and Structs</h1>
<p>Function parameters aren&rsquo;t the only context in which lifetimes appear. When a struct declares a member with a reference type, the lifetime of that member must also be declared. The example below won&rsquo;t compile.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>    name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> <span style="color:#75715e">// error: expected lifetime parameter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> Person { name: <span style="color:#e6db74">&#34;Alice&#34;</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;alice: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, alice);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here, the compiler can&rsquo;t rule out cases in which the <code>name</code> member is dropped before its enclosing <code>Person</code> instance. We can correct this problem by adding a lifetime parameter <code>'a</code>. In doing so, we notify the compiler that <code>name</code> will live at least as long as its parent.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    name: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> alice <span style="color:#f92672">=</span> Person { name: <span style="color:#e6db74">&#34;Alice&#34;</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;alice: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, alice);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="mutability">Mutability</h1>
<p>So far we&rsquo;ve only considered values that never change. But writing real software requires state changes — mainly through changes to the state of values. This capability of changing the state of a value is known as <em>mutability</em>.</p>
<p>Mutability may seem unrelated to ownership, but the two concepts are tightly coupled. In particular, mutability constrains your ability to borrow references.</p>
<p>In Rust, variables own immutable values by default. We can override this behavior by preceding a variable with the <code>mut</code> keyword.</p>
<p>For example, we&rsquo;re unable to add members to a <code>Vec</code> by default:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> numbers <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    numbers.push(<span style="color:#ae81ff">4</span>); <span style="color:#75715e">// ERROR: cannot borrow as mutable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;numbers: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, numbers);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Making the owner mutable solves this problem.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> numbers <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    numbers.push(<span style="color:#ae81ff">4</span>);  <span style="color:#75715e">// mutable Vec supports push
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;numbers: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, numbers);  <span style="color:#75715e">// numbers: [1, 2, 3, 4]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h1 id="marsaw-multiple-active-readers-or-single-active-writer">MARSAW: Multiple Active Readers or Single Active Writer</h1>
<p>Mutability constrains our ability to borrow references. The book <em><a href="https://www.oreilly.com/library/view/programming-rust/9781491927274/">Programming Rust</a></em> refers to the high-level concept as <em>multiple readers or single writer</em>.</p>
<p><em><a href="https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html#the-rules">The Rust Programming Language</a></em> describes the same principle like so:</p>
<blockquote>
<p>&hellip; you may have one or the other of these two kinds of borrows, but not both at the same time:</p>
<ul>
<li>one or more references (<code>&amp;T</code>) to a resource,</li>
<li>exactly one mutable reference (<code>&amp;mut T</code>).</li>
</ul>
</blockquote>
<p>Neither description, however, quite hits the mark. First, the rule applies to both borrowed references and <em>owners</em>. Second, the rule only applies when <em>active</em> readers and writers are involved. As such, it might be more instructive to recast the rule as: &ldquo;multiple active readers or single active writer&rdquo; (MARSAW).</p>
<p>The term &ldquo;active&rdquo; deserves some explanation. Until a writer&rsquo;s mutable API is used, it&rsquo;s inactive. After mutation, the writer stays active for the duration of its lifetime. A reader borrowed before the activation of a writer will become active on the first use of the owner&rsquo;s immutable API.</p>
<p>Let&rsquo;s look at some examples to make these ideas more concrete.</p>
<p>One <em>inactive</em> writer and one <em>inactive</em> reader can co-exist within the same scope, as demonstrated below. You&rsquo;ll notice warnings about unused variables, but no errors.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];   <span style="color:#75715e">// inactive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;           <span style="color:#75715e">// inactive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>We can read without triggering an error, although we&rsquo;ll receive an additional warning about unneeded mutability on <code>writer</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;len: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, reader.len()); <span style="color:#75715e">// no error, inactive writer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Likewise, we write without triggering a compiler error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    writer.push(<span style="color:#ae81ff">4</span>);  <span style="color:#75715e">// no error, inactive reader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>We can take this further with sequential read-write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;len: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, reader.len()); <span style="color:#75715e">// no error, inactive writer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    writer.push(<span style="color:#ae81ff">4</span>);                    <span style="color:#75715e">// no error, inactive reader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>We can exercise <code>writer</code>&rsquo;s immutable API, then read without producing an error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    writer.len();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;len: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, reader.len()); <span style="color:#75715e">// no error: inactive reader and writer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>What we can&rsquo;t do is activate <code>writer</code> then use <code>reader</code>. The following code produces an error because the <code>println!</code> statement generates an active reader, which when paired with the active writer is not allowed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    writer.push(<span style="color:#ae81ff">4</span>);                    <span style="color:#75715e">// error: cannot borrow `writer` as mutable because it is also borrowed as immutable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;len: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, reader.len());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The error message explains the situation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>3 |     let reader = &amp;writer;
</span></span><span style="display:flex;"><span>  |                  ------- immutable borrow occurs here
</span></span><span style="display:flex;"><span>4 | 
</span></span><span style="display:flex;"><span>5 |     writer.push(4);                    // active writer, inactive reader
</span></span><span style="display:flex;"><span>  |     ^^^^^^^^^^^^^^ mutable borrow occurs here
</span></span><span style="display:flex;"><span>6 |     
</span></span><span style="display:flex;"><span>7 |     println!(&#34;len: {}&#34;, reader.len()); // error: cannot borrow `writer` as mutable because it is also borrowed as immutable
</span></span><span style="display:flex;"><span>  |                         ------ immutable borrow later used here
</span></span></code></pre></div><p>We can eliminate the error by pulling the borrow down after the call to <code>push</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    writer.push(<span style="color:#ae81ff">4</span>); 
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> reader <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>writer;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;len: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, reader.len()); <span style="color:#75715e">// no error, reader is not active because it was borrowed _after_ last writer mutation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Even though a variable might be declared as <code>mut</code>, it can nevertheless be used to read. Note that <code>writer.iter</code> triggers an implicit immutable borrow. This does not violate MARSAW, however, because the borrow occurs after the last mutation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    writer.push(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> number <span style="color:#66d9ef">in</span> writer.iter() {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;number: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, number); <span style="color:#75715e">// no error, implicit borrow occurs after writer mutation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Implicit borrowing can nevertheless lead to a MARSAW violation if coupled to a write. The following code won&rsquo;t compile because the <code>iter</code> method implicitly borrows an immutable reference, creating a simultaneously active reader and writer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> number <span style="color:#66d9ef">in</span> writer.iter() {
</span></span><span style="display:flex;"><span>        writer.push(number <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// ERROR: cannot borrow `writer` as mutable because it is also borrowed as immutable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The error (below) lets us know where borrowing occurs. Used together with the MARSAW principle, we can identify the problem&rsquo;s source as an <em>active</em> reader and writer operating simultaneously.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>4 |     for number in writer.iter() {
</span></span><span style="display:flex;"><span>  |                   -------------
</span></span><span style="display:flex;"><span>  |                   |
</span></span><span style="display:flex;"><span>  |                   immutable borrow occurs here
</span></span><span style="display:flex;"><span>  |                   immutable borrow later used here
</span></span><span style="display:flex;"><span>5 |         writer.push(number + 2); // ERROR: cannot borrow `writer` as mutable because it is also borrowed as immutable
</span></span><span style="display:flex;"><span>  |         ^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
</span></span></code></pre></div><h1 id="conclusion">Conclusion</h1>
<p>Ownership permeates Rust, so it&rsquo;s critical to understand it early in your study of the language. This guide offers some simple examples illustrating how ownership works. Key points can be summarized as:</p>
<ol>
<li>Assignment always binds a value to a variable, which becomes the value&rsquo;s sole owner.</li>
<li>Passing and returning by value both count as assignment.</li>
<li>A value will always be dropped by the time its owner goes out of scope.</li>
<li>Reassignment of a value results in a move, or change of ownership.</li>
<li>After a move, the former assignee can never be used again.</li>
<li>A reference can be borrowed through reassignment by preceding its owner with the ampersand symbol (<code>&amp;</code>).</li>
<li>A borrowed reference may not live longer than the underlying value.</li>
<li>A lifetime parameter, written with an apostrophe character (<code>'</code>) followed by at least one letter, represents the scope of a borrowed reference.</li>
<li>A lifetime parameter identifies two references as having the same minimum scope.</li>
<li>The MARSAW principle allows for either multiple readers or a single writer to be active at the same time, but not both. Owners and references both count.</li>
</ol>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Depth-First 2024 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
