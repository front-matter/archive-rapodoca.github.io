<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Let&#39;s Build a SMILES Parser in Rust | Depth-First</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Toward a suite of toolkit-agnostic utilities for the SMILES language.">
    <meta name="generator" content="Hugo 0.139.4">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    
      <meta name="author" content = "Richard L. Apodaca">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/articles/2020/05/25/lets-build-a-smiles-parser-in-rust/">
    

    <meta property="og:url" content="http://localhost:1313/articles/2020/05/25/lets-build-a-smiles-parser-in-rust/">
  <meta property="og:site_name" content="Depth-First">
  <meta property="og:title" content="Let&#39;s Build a SMILES Parser in Rust">
  <meta property="og:description" content="Toward a suite of toolkit-agnostic utilities for the SMILES language.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-05-25T16:00:00+00:00">
    <meta property="article:modified_time" content="2020-05-25T16:00:00+00:00">

  <meta itemprop="name" content="Let&#39;s Build a SMILES Parser in Rust">
  <meta itemprop="description" content="Toward a suite of toolkit-agnostic utilities for the SMILES language.">
  <meta itemprop="datePublished" content="2020-05-25T16:00:00+00:00">
  <meta itemprop="dateModified" content="2020-05-25T16:00:00+00:00">
  <meta itemprop="wordCount" content="1673">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Let&#39;s Build a SMILES Parser in Rust">
  <meta name="twitter:description" content="Toward a suite of toolkit-agnostic utilities for the SMILES language.">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Depth-First
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Let&#39;s Build a SMILES Parser in Rust</h1>
      
      <p class="tracked">
        By <strong>Richard L. Apodaca</strong>
      </p>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2020-05-25T16:00:00Z">May 25, 2020</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>SMILES is a widely-used language for chemical structure exchange. As such, no cheminformatics toolkit today would be complete without a SMILES reader and writer. This article describes the design and initial implementation of <a href="https://github.com/rapodaca/purr">Purr</a>, a toolkit-agnostic library for working with SMILES in Rust. In its current form, Purr can parse most of the SMILES language.</p>
<p>Previous articles from this blog may be helpful in understanding Purr&rsquo;s purpose and design. <a href="/articles/2020/01/20/cheminformatics-in-rust/">Rust makes a compelling language choice</a> for several reasons. The <a href="/articles/2020/04/20/smiles-formal-grammar/">SMILES grammar</a> is woven deeply into Purr. <a href="/articles/2020/05/04/stereochemistry-and-atom-parity-in-smiles/">Stereochemistry and atom parity</a> played a crucial role in Purr&rsquo;s approach to bonding representation. Purr follows the release of a <a href="/articles/2020/05/11/cheminformatics-in-rust-implementing-a-minimal-molecule-api/">foundational layer</a> of a Rust cheminformatics toolkit. That work was in turn based on a <a href="/articles/2020/01/06/a-minimal-graph-api/">minimal Molecule API</a> which itself builds on a somewhat unusual take on <a href="/articles/2020/02/17/graphs-in-rust-introducting-graphcore/">graphs in Rust</a>.</p>
<h1 id="the-code">The Code</h1>
<p>The Purr repository is hosted on <a href="https://github.com/rapodaca/purr">GitHub</a>. Using it will require a <a href="https://rustup.rs">Rust installation</a>.</p>
<p>Clone the repository and run its test suite with the following commands:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>git clone https://github.com/rapodaca/purr
</span></span><span style="display:flex;"><span>cd purr
</span></span><span style="display:flex;"><span>cargo test
</span></span></code></pre></div><p>The remainder of this article describes the design and implementation of Purr.</p>
<h1 id="data-structures">Data Structures</h1>
<p>Purr is organized around the <code>Mol</code> data structure which exposes two public attributes â€” one representing a list of <code>Atom</code>s and the other representing a list of <code>Bond</code>s. This design follows from the observation that SMILES encodes a molecular graph. It seems reasonable that the output of a SMILES parser would be a graph-like object. To this end, Purr defines a total of four flat data structures that closely align with the related concepts in the SMILES language.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// simplified listing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Mol</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> atoms: Vec<span style="color:#f92672">&lt;</span>Atom<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> bonds: Vec<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>Bond<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Atom</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> element: <span style="color:#a6e22e">Element</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> aromatic: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> isotope: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u16</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> hcount: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> charge: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i8</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> parity: Option<span style="color:#f92672">&lt;</span>Parity<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> map: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Bond</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> tid: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> style: Option<span style="color:#f92672">&lt;</span>Style<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Style</span> {
</span></span><span style="display:flex;"><span>    Single,
</span></span><span style="display:flex;"><span>    Double,
</span></span><span style="display:flex;"><span>    Triple,
</span></span><span style="display:flex;"><span>    Quadruple,
</span></span><span style="display:flex;"><span>    Up,
</span></span><span style="display:flex;"><span>    Down,
</span></span><span style="display:flex;"><span>    Aromatic
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>bonds</code> attribute of <code>Mol</code> deserves some attention. This jagged 2D array represents an <a href="https://en.wikipedia.org/wiki/Adjacency_list">adjacency list</a> graph representation. In other words, <code>bonds</code> indexes the list of bonds associated with a given atomic ID. For example, to find the list of bonds at atomic ID 0, use <code>bonds[0]</code>, and so on.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> mol <span style="color:#f92672">=</span> get_mol(); <span style="color:#75715e">// get_mol is defined somewhere else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;Bond list at ID 1: </span><span style="color:#e6db74">{:#?}</span><span style="color:#e6db74">&#34;</span>, mol.bonds.get(<span style="color:#ae81ff">1</span>).unwrap());
</span></span></code></pre></div><p>Also note that <code>Bond</code> defines only two attributes: the ID of the target atom (<code>tid</code>) and an optional bond <code>Style</code>. A source atom ID would be redundant, so it isn&rsquo;t used. The <code>style</code> attribute represents one of the seven valid SMILES bond types. Dot (<code>.</code>) is not a bond type and so it is not included within the <code>Style</code> enum.</p>
<p>An adjacency list may seem like overkill. Why not use an <a href="https://en.wikipedia.org/wiki/Edge_list">edge list</a> instead? This could be accomplished with an <code>edges</code> attribute represented by a flat <code>Vec&lt;Bond&gt;</code>. The reason relates to the interplay between atom parity and rings.</p>
<p>As noted in a previous article, <a href="/articles/2020/05/04/stereochemistry-and-atom-parity-in-smiles/">atom parity in SMILES</a> depends on the <em>order</em> in which neighboring atoms are added. A ring in SMILES is represented as a cut in which the target atom is only revealed after parsing progresses to the right. A parser must therefore record the exact order of substituent addition for each atom independently. An adjacency list fulfils this requirement, but an edge list does not.</p>
<h1 id="scanner">Scanner</h1>
<p>Parsing follows the <a href="/articles/2019/01/22/scanner-driven-parser-development/">Scanner-driven parser development</a> method previously outlined on this blog. To recap, this method features an object of type <code>Scanner</code>. A <code>Scanner</code> moves a cursor from left to right over a string. The next character can be &ldquo;peeked&rdquo; (reversibly examined), or &ldquo;popped&rdquo; (irreversibly examined). Popping the scanner advances the cursor by one characters. The cursor can only be incremented, so moving backward is impossible. This simplicity of operation and lack of backtracking makes recursive descent parsing efficient.</p>
<h1 id="smiles-grammar">SMILES Grammar</h1>
<p>As described previously, <a href="/articles/2020/04/20/smiles-formal-grammar/">the SMILES formal grammar can be cast into LL(1) form</a>. Doing so offers important advantages. For one, numerous automated parser generators operate over LL(1) grammars, vastly simplifying grammar development and testing. Secondly, an LL(1) grammar makes an excellent blueprint for a hand-crafted recursive-descent parser. This is the approach used in Purr.</p>
<p>A similar approach to the one described here has been successfully used in the JavaScript-based cheminformatics toolkit within <a href="https://chemwriter.com/smiles/">ChemWriter</a>.</p>
<h1 id="builder">Builder</h1>
<p>Before tackling parsing itself, there&rsquo;s one more piece of business we need to consider. A recursive descent parser needs to build some kind of representation of the contents being parsed. This representation is sometimes called a &ldquo;parse tree.&rdquo; In Purr, the result of a parse is a <code>Mol</code> object.</p>
<p>Keeping track of the state required to build a <code>Mol</code> is non-trivial. I&rsquo;ve found it much easier to separate the creation of the state object from parsing. My solution is a <code>Builder</code>.</p>
<p><code>Builder</code> provides a simple API for building a <code>Mol</code>. All methods except one are mutators reflecting the kinds of actions taken when reading a SMILES string from left to right: creation from a root atom; setting a bond style; connecting a new atom to the root; opening or closing a ring; opening or closing a branch; and beginning a new root.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// simplified listing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Builder</span> {
</span></span><span style="display:flex;"><span>    atoms: Vec<span style="color:#f92672">&lt;</span>Atom<span style="color:#f92672">&gt;</span>,      <span style="color:#75715e">// atoms to be added
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bonds: Vec<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>Bond<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#75715e">// adjacency list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    style: Option<span style="color:#f92672">&lt;</span>Style<span style="color:#f92672">&gt;</span>,  <span style="color:#75715e">// the current bond style
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    stack: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>,     <span style="color:#75715e">// used for opening/closing branches
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    root: <span style="color:#66d9ef">usize</span>,           <span style="color:#75715e">// id of atom to be extended
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cuts: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span>, Cut<span style="color:#f92672">&gt;</span> <span style="color:#75715e">// rnum to Cut mapping
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Builder {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(root: <span style="color:#a6e22e">Atom</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Returns a Builder struct, adding root to atoms and setting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// self.root to 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">root</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, atom: <span style="color:#a6e22e">Atom</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Begins a new root when dot (.) bond found
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">extend</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, atom: <span style="color:#a6e22e">Atom</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Create a bond between current root and atom
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">bond</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, style: <span style="color:#a6e22e">Style</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Sets the current bond style
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">open</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Opens a branch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">close</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Closes a branch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, rnum: <span style="color:#66d9ef">u8</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Opens or closes a ring identified by rnum.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// Returns an error if the left/right bond styles are
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// incompatible.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">to_mol</span>(self) -&gt; Result<span style="color:#f92672">&lt;</span>Mol, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Consumes this Builder and returns the Mol under construction,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// or an error given invalid state (open rings or branches).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Cut</span> {
</span></span><span style="display:flex;"><span>    id: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>    index: <span style="color:#66d9ef">usize</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Having instantiated a <code>Builder</code>, a parser can maintain singular focus on translating SMILES tokens into <code>Builder</code> API calls.</p>
<h1 id="the-smiles_to_mol-function">The <code>smiles_to_mol</code> Function</h1>
<p>Having discussed data structures and helpers, we&rsquo;re now in a position to consider the <code>smiles_to_mol</code> function itself. This function accepts a <a href="https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices">string slice</a>. If it represents a valid SMILES, the corresponding <code>Mol</code> is returned. Otherwise an <code>Error</code> is returned.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">smiles_to_mol</span>(text: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Mol, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> scanner <span style="color:#f92672">=</span> Scanner::new(text);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> scanner.done() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Err(Error::EndOfLine);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(atom) <span style="color:#f92672">=</span> bare_atom(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> scanner)<span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> state <span style="color:#f92672">=</span> State {
</span></span><span style="display:flex;"><span>            scanner: <span style="color:#a6e22e">scanner</span>,
</span></span><span style="display:flex;"><span>            builder: <span style="color:#a6e22e">Builder</span>::new(atom),
</span></span><span style="display:flex;"><span>            dot: <span style="color:#a6e22e">false</span>
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>chain(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> state)<span style="color:#f92672">?</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>branch(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> state)<span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>state.scanner.done() {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span> Err(Error::InvalidCharacter(state.scanner.cursor()))
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span> <span style="color:#66d9ef">match</span> state.builder.to_mol() {
</span></span><span style="display:flex;"><span>                    Ok(molecule) <span style="color:#f92672">=&gt;</span> Ok(molecule),
</span></span><span style="display:flex;"><span>                    Err(_) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        unimplemented!()
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        Err(Error::InvalidCharacter(<span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The top-level function creates a <code>Scanner</code> from the string slice. If the scanner is done, then the function exits early with a <code>false</code> result. Otherwise, the <code>bare_atom</code> helper is called to parse the root atom. If that fails, an error is returned. Otherwise, a private <code>State</code> struct is created. <code>State</code> combines a <code>Scanner</code>, a <code>Builder</code>, and a boolean flag indicating whether or not a dot (<code>.</code>) token was recently seen. Then, a loop reads chains and branches until an error is encountered (via the <code>?</code> operator), the scanner terminates, or no new tokens can be read.</p>
<p>If you haven&rsquo;t done so already, this would be a good time to review the <a href="/articles/2020/04/20/smiles-formal-grammar/">SMILES formal grammar</a>. Close correlation between both the structure and names of the helper functions in <code>smiles_to_mol</code> and the grammar will be seen throughout <code>smiles_to_mol</code>.</p>
<p>Rather than discuss all of the helper functions, here I&rsquo;ll just highlight a few that illustrate the main points.</p>
<p>The <code>chain</code> helper function greedily parses a sequence of atoms, returning when no more progress is possible. Notice the correlation between the production rule <code>&lt;chain&gt;</code> and the layout of the function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// &lt;chain&gt; ::= ( &lt;dot&gt; &lt;atom&gt; | &lt;bond&gt;? ( &lt;atom&gt; | &lt;rnum&gt;) )+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">chain</span>(state: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> State) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span>, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> dot(state)<span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>atom(state)<span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span> Err(Error::InvalidCharacter(state.scanner.cursor()))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> bond(state)<span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>atom(state)<span style="color:#f92672">?</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>rnum(state)<span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span> Err(Error::InvalidCharacter(state.scanner.cursor()))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>atom(state)<span style="color:#f92672">?</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>rnum(state)<span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span> Ok(result)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>branch</code> helper greedily parses a branch enclosed by opening and closing parentheses (<code>(</code> and <code>)</code>, respectively). After popping an open parentheses (<code>(</code>), a loop is entered. It terminates if the <code>Scanner</code> is done or if a close parentheses (<code>)</code>) is found. An <code>Error</code> will be triggered by failure to find a closing <code>)</code> or failure to find a <code>&lt;line&gt;</code> construct within the branch. The <code>open</code> and <code>close</code> methods of <code>Builder</code> keep track of practically unlimited levels of nesting.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// &lt;branch&gt; ::= &#34;(&#34; ( &lt;bond&gt;? &lt;line&gt; )+ &#34;)&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">branch</span>(state: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> State) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span>, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(<span style="color:#e6db74">&#39;(&#39;</span>) <span style="color:#f92672">=</span> state.scanner.peek() {
</span></span><span style="display:flex;"><span>        state.scanner.pop();
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Ok(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    state.builder.open();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">!</span>state.scanner.done() {
</span></span><span style="display:flex;"><span>        bond(state)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>line(state)<span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Err(Error::InvalidCharacter(state.scanner.cursor()));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(<span style="color:#e6db74">&#39;)&#39;</span>) <span style="color:#f92672">=</span> state.scanner.peek() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    state.builder.close();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> state.scanner.pop() {
</span></span><span style="display:flex;"><span>        Some(<span style="color:#e6db74">&#39;)&#39;</span>) <span style="color:#f92672">=&gt;</span> Ok(<span style="color:#66d9ef">true</span>),
</span></span><span style="display:flex;"><span>        Some(_) <span style="color:#f92672">=&gt;</span> Err(Error::InvalidCharacter(state.scanner.cursor())),
</span></span><span style="display:flex;"><span>        None <span style="color:#f92672">=&gt;</span> Err(Error::EndOfLine)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="conclusion">Conclusion</h1>
<p>Purr is a low-level Rust library for working with SMILES. It currently includes a parser capable of correctly processing all language elements. A SMILES writer should be straightforward to implement given a depth-first traversal and existing Purr data structures. The combination of a low-level <code>Molecule</code> implementation as already described, and a Purr reader/writer would create a solid foundation for a future cheminformatics toolkit in Rust.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Depth-First 2024 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
