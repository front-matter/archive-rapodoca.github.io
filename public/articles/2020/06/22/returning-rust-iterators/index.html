<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Returning Rust Iterators | Depth-First</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Some simple tricks go a long way when dealing with iterators as return values.">
    <meta name="generator" content="Hugo 0.139.4">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/articles/2020/06/22/returning-rust-iterators/">
    

    <meta property="og:url" content="http://localhost:1313/articles/2020/06/22/returning-rust-iterators/">
  <meta property="og:site_name" content="Depth-First">
  <meta property="og:title" content="Returning Rust Iterators">
  <meta property="og:description" content="Some simple tricks go a long way when dealing with iterators as return values.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-06-22T17:00:00+00:00">
    <meta property="article:modified_time" content="2020-06-22T17:00:00+00:00">

  <meta itemprop="name" content="Returning Rust Iterators">
  <meta itemprop="description" content="Some simple tricks go a long way when dealing with iterators as return values.">
  <meta itemprop="datePublished" content="2020-06-22T17:00:00+00:00">
  <meta itemprop="dateModified" content="2020-06-22T17:00:00+00:00">
  <meta itemprop="wordCount" content="1827">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Returning Rust Iterators">
  <meta name="twitter:description" content="Some simple tricks go a long way when dealing with iterators as return values.">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Depth-First
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Returning Rust Iterators</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2020-06-22T17:00:00Z">June 22, 2020</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Rust iterators are fundamental to the language and can be found in a variety of contexts. Consuming iterators returned from functions in the standard library and crates is straightforward. Eventually, however, you&rsquo;ll want to return iterators from your own functions. This article discusses the major approaches to this surprisingly complex problem. It&rsquo;s based in part on answers to <a href="https://stackoverflow.com/questions/27535289/what-is-the-correct-way-to-return-an-iterator-or-any-other-trait">this question</a>.</p>
<h1 id="returning-an-iterator">Returning an Iterator</h1>
<p>The simplest scenario is one in which an iterator is obtained and returned without further modification. Consider a container that owns a <code>Vec&lt;u8&gt;</code>. We&rsquo;d like the container to implement a method <code>values</code> that returns an iterator over the members of the list.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Container</span> {
</span></span><span style="display:flex;"><span>    items: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Container {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: add a #values method that returns an iterator over items
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><code>Vec</code> is perfectly capable of returning an iterator, so it seems logical to use it. But what&rsquo;s the type? <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter">The documentation</a> informs us that it&rsquo;s <a href="https://doc.rust-lang.org/std/slice/struct.Iter.html"><code>std::slice::Iter</code></a>.</p>
<p>Here&rsquo;s an even easier way: ask the compiler. Begin by writing a method that declares the unit primitive (<code>()</code>) as the return type while actually returning the iterator.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Container</span> {
</span></span><span style="display:flex;"><span>    items: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Container {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">values</span>(<span style="color:#f92672">&amp;</span>self) -&gt; () {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Use the error to find the return type that should be declared
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      self.items.iter()
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The compiler produces an error. VS Code running a Rust plugin displays it in real time. Alternatively the compiler prints the error when the build system runs.</p>
<!-- raw HTML omitted -->
<p>The type is contained within the error message, from which it can be copied. Replace the dummy unit primitive with the value on the clipboard. In this case, the type can be used as-is. Situations with declared lifetimes will, however, require some adjustments.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Container</span> {
</span></span><span style="display:flex;"><span>    items: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Container {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">values</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">std</span>::slice::Iter<span style="color:#f92672">&lt;</span>&#39;_, <span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>      self.items.iter()
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="intercepting-an-iterator">Intercepting an Iterator</h1>
<p>Things get more complicated if more processing is needed. Consider a container with an <code>items</code> list, but this time holding a struct. Our goal is to iterate, not the structs, but borrowed references to the values they contain.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Wrapper</span> {
</span></span><span style="display:flex;"><span>    value: <span style="color:#66d9ef">u8</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Container</span> {
</span></span><span style="display:flex;"><span>    items: Vec<span style="color:#f92672">&lt;</span>Wrapper<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Container {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: add a method that iterates over Wrapper.value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>The <code>items</code> list can produce a perfectly suitable iterator for <code>Wrapper</code> values, but the goal here is to iterate the <code>u8</code> value each one holds. How can we expose them?</p>
<h1 id="mapping-an-iterator">Mapping an Iterator</h1>
<p>It&rsquo;s tempting to bring out <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map"><code>Iterator#map</code></a>. This method works like JavaScript&rsquo;s <code>Array#map</code> method, allowing a stream of input values to be transformed 1:1 into a stream of output values. Unlike JavaScript&rsquo;s <code>Array#map</code>, Rust&rsquo;s <code>Iterator#map</code> applies to an iterator and as such is more flexible.</p>
<p>The first task is to obtain the return value by declaring a unit return type.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Wrapper</span> {
</span></span><span style="display:flex;"><span>    value: <span style="color:#66d9ef">u8</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Container</span> {
</span></span><span style="display:flex;"><span>    items: Vec<span style="color:#f92672">&lt;</span>Wrapper<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Container {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// COMPILER ERROR
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">values</span>(<span style="color:#f92672">&amp;</span>self) -&gt; () {
</span></span><span style="display:flex;"><span>        self.items.iter().map(<span style="color:#f92672">|</span>wrapper<span style="color:#f92672">|</span> wrapper.value)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As expected, the compiler issues a warning. Unexpectedly, the required return type looks odd: <code>std::iter::Map&lt;std::slice::Iter&lt;'_, Wrapper&gt;, [closure@src/lib.rs:11:31: 11:54]&gt;</code> (your error will vary depending on the exact source file). I haven&rsquo;t found much documentation on exactly what&rsquo;s going on. Even so, it <a href="https://stackoverflow.com/a/30641982">appears</a> to be impossible to use this technique directly. Fortunately, there&rsquo;s a workaround.</p>
<h1 id="impl-trait"><code>impl Trait</code></h1>
<p>All of Rust&rsquo;s iterators implement the <code>Iterator</code> trait. Instead of declaring a concrete iterator type, can a trait be declared as the type of a return value? The answer is &ldquo;yes,&rdquo; but with some caveats. The code below does the job.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Wrapper</span> {
</span></span><span style="display:flex;"><span>    value: <span style="color:#66d9ef">u8</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Container</span> {
</span></span><span style="display:flex;"><span>    items: Vec<span style="color:#f92672">&lt;</span>Wrapper<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Container {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">values</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">impl</span> Iterator<span style="color:#f92672">&lt;</span>Item<span style="color:#f92672">=</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> &#39;_ {
</span></span><span style="display:flex;"><span>        self.items.iter().map(<span style="color:#f92672">|</span>wrapper<span style="color:#f92672">|</span> wrapper.value)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The keyword <a href="https://doc.rust-lang.org/beta/std/keyword.impl.html"><code>impl</code></a> signals that the return type is a trait. Misleadingly, omission of the <code>impl</code> keyword yields the error: &ldquo;trait objects without an explicit <code>dyn</code> are deprecated.&rdquo; The fix here is to use <code>impl</code>, not <code>dyn</code>. We&rsquo;ll see when to apply the latter keyword shortly. Omitting <code>dyn</code> also produces a second error: &ldquo;doesn&rsquo;t have a size known at compile-time.&rdquo; The error occurs because by default the compiler expects a return value to be allocated on the stack, which in turn requires a size known at compile time. Using the <code>impl</code> keyword allows the compiler to relax this restriction.</p>
<p>The reasons behind the lifetime notation <code>+ '_</code> are interesting, but not relevant here. For details, see: <em><a href="https://blog.katona.me/2019/12/29/Rust-Lifetimes-and-Iterators/">Rust Lifetimes and Iterators</a></em>.</p>
<p><a href="https://doc.rust-lang.org/beta/book/ch10-02-traits.html#returning-types-that-implement-traits">The Rust Book</a> has this to say on what <code>impl Trait</code> actually does:</p>
<blockquote>
<p>The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators &hellip; [which] create types that only the compiler knows or types that are very long to specify. The impl Trait syntax lets you concisely specify that a function returns some type that implements the Iterator trait without needing to write out a very long type.</p>
</blockquote>
<p>The book goes on to note that <code>impl Trait</code> can only be used to return a single type. In other words, think of the construct as a convenient shorthand for an otherwise cumbersome or inaccessible type.</p>
<p>A more important restriction in my experience is that <code>impl Trait</code> can&rsquo;t be returned from a method defined on a trait. Attempting to do so will yield the error &ldquo;<code>impl Trait</code> not allowed outside of function and inherent method return types.&rdquo;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Foo {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ERROR: `impl Trait` not allowed outside of function and inherent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// method return types
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">foo</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">impl</span> Iterator<span style="color:#f92672">&lt;</span>Item<span style="color:#f92672">=</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> &#39;_;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="associated-type">Associated Type</h1>
<p>It&rsquo;s often useful to bundle behavior into traits. But as we&rsquo;ve seen, returning iterators from traits with <code>impl Type</code> doesn&rsquo;t work. Fortunately, Rust offers a workaround in the form of <em><a href="https://doc.rust-lang.org/stable/rust-by-example/generics/assoc_items/types.html">associated types</a></em>.</p>
<p>An associated type uses the keyword <code>type</code> within the body of a trait. Associated types can be identified through the notation <code>&lt;Name=type&gt;</code>. You may have noticed that the <code>Iterator</code> trait uses an associated type called <code>Item</code>.</p>
<p>We can apply associated types to the problem of returning an iterator from a method on a trait.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Container<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ItemIterator</span>: Iterator<span style="color:#f92672">&lt;</span>Item<span style="color:#f92672">=&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">items</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> self) -&gt; <span style="color:#a6e22e">Self</span>::ItemIterator;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>Container</code> method <code>items</code> requires a return type of <code>ItemIterator</code>. Concrete types can choose any <code>Iterator</code> implementation, provided that it produces a sequence of <code>u8</code> references. These criteria can be met with the following implementation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">VecContainer</span> {
</span></span><span style="display:flex;"><span>    items: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> Container<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> VecContainer {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ItemIterator</span> <span style="color:#f92672">=</span> std::slice::Iter<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, <span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">items</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> self) -&gt; <span style="color:#a6e22e">Self</span>::ItemIterator {
</span></span><span style="display:flex;"><span>        self.items.iter()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Unlike previous examples, lifetimes require some attention here.</p>
<p>Unfortunately, associated types won&rsquo;t do much good when an implementation tries to return a mapped iterator. The same old problem from before rears its head, namely that we can&rsquo;t specify the type of an iterator involving closures.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">VecContainer</span> {
</span></span><span style="display:flex;"><span>    items: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> Container<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> VecContainer {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ItemIterator</span> <span style="color:#f92672">=</span> ();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">items</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> self) -&gt; <span style="color:#a6e22e">Self</span>::ItemIterator {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ERROR: expected std::iter::Map&lt;std::slice::Iter&lt;&#39;_, u8&gt;,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// [closure@src/lib.rs:15:31: 15:47]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        self.items.iter().map(<span style="color:#f92672">|</span>item<span style="color:#f92672">|</span> <span style="color:#f92672">*</span>item <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="trait-objects">Trait Objects</h1>
<p>One way to break out of the restrictions imposed on return types from trait methods is a <em><a href="https://tratt.net/laurie/blog/entries/a_quick_look_at_trait_objects_in_rust.html">trait object</a></em>. According to the <a href="https://doc.rust-lang.org/reference/types/trait-object.html">Rust Book</a>, a trait object &ldquo;is an opaque value of another type that implements a set of traits.&rdquo; A trait object can be identified through the use of the construct <code>dyn Trait</code>.</p>
<p>We can solve the problem of mapped iterators being returned from trait methods as follows.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Wrapper</span> {
</span></span><span style="display:flex;"><span>    value: <span style="color:#66d9ef">u8</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Container {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">items</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Iterator<span style="color:#f92672">&lt;</span>Item<span style="color:#f92672">=&amp;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> &#39;_<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">VecContainer</span> {
</span></span><span style="display:flex;"><span>    items: Vec<span style="color:#f92672">&lt;</span>Wrapper<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Container <span style="color:#66d9ef">for</span> VecContainer {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">items</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Iterator<span style="color:#f92672">&lt;</span>Item<span style="color:#f92672">=&amp;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> &#39;_<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        Box::new(self.items.iter().map(<span style="color:#f92672">|</span>wrapper<span style="color:#f92672">|</span> <span style="color:#f92672">&amp;</span>wrapper.value))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We previously saw how a type with an unknown size can&rsquo;t be returned from a method. Trait objects are dynamically sized, raising the question of why the above code compiles. The answer is that the return value is boxed. By default, Rust values are allocated on the stack. <code>Box</code> allocates its contained value on the heap instead, retaining a fixed-size pointer. As a result, a <code>Box</code> containing any variable-sized type can be returned from any method or function.</p>
<p>What are the performance tradeoffs of such an approach? Unfortunately, the answer isn&rsquo;t clear. I&rsquo;ve found more questions asked on this topic than actionable answers. For example:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/28621980/">What are the actual runtime performance costs of dynamic dispatch?</a></li>
<li><a href="https://users.rust-lang.org/t/performance-implications-of-box-trait-vs-enum-delegation/11957">Performance implications of <code>Box&lt;Trait&gt;</code> vs <code>enum</code> delegation</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/74llky/trait_objects_22x_slower_than_static_dispatch/">trait objects: 22x slower than static dispatch?</a></li>
</ul>
<p>Aside from performance, two points about trait objects as return values are clear:</p>
<ol>
<li>They&rsquo;re rare in the standard library API.</li>
<li>They&rsquo;re uncommon in Rust crate APIs.</li>
</ol>
<p>The more used the function call, the less appetizing <code>Iterator</code> trait objects look purely on a design basis. Should performance prove to become a bottleneck, a costly round of changes could result.</p>
<h1 id="simple-iterator-delegation">Simple Iterator Delegation</h1>
<p>Fortunately, we can have our cake and eat it, too. We can stay on the happy path of static dispatch and stack allocation while at the same time returning iterators that perform inline processing.</p>
<p>We begin with an example using unproductive <code>Iterator</code> delegation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Container</span> {
</span></span><span style="display:flex;"><span>    items: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Container {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">values</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">Repeater</span> {
</span></span><span style="display:flex;"><span>      Repeater { iter: <span style="color:#a6e22e">self</span>.items.iter() }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Repeater</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    iter: <span style="color:#a6e22e">std</span>::slice::Iter<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, <span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> Iterator <span style="color:#66d9ef">for</span> Repeater<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">u8</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>Self::Item<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        self.iter.next()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the above example, <code>values</code> returns the custom <code>Iterator</code> implementation <code>Repeater</code>. But rather than starting from scratch, that implementation delegates to the private field <code>iter</code>. Whatever it iterates is returned verbatim.</p>
<h1 id="complex-iterator-delegation">Complex Iterator Delegation</h1>
<p>Delegation makes it possible to construct sophisticated iterators from simple primitives. Consider once again the problem of iterating over one or more fields borrowed from the members of a <code>Vec</code>. To solve it, <code>Repeater</code> can be tweaked to return a borrowed field from a wrapper struct.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Wrapper</span> {
</span></span><span style="display:flex;"><span>    value: <span style="color:#66d9ef">u8</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Container</span> {
</span></span><span style="display:flex;"><span>    items: Vec<span style="color:#f92672">&lt;</span>Wrapper<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Container {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">values</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">Inspector</span> {
</span></span><span style="display:flex;"><span>        Inspector { iter: <span style="color:#a6e22e">self</span>.items.iter() }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Inspector</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    iter: <span style="color:#a6e22e">std</span>::slice::Iter<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, Wrapper<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> Iterator <span style="color:#66d9ef">for</span> Inspector<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">u8</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>Self::Item<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        self.iter.next().map(<span style="color:#f92672">|</span>wrapper<span style="color:#f92672">|</span> <span style="color:#f92672">&amp;</span>wrapper.value)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Inspector</code> uses the <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>Option#map</code></a> method together with a closure to iterate, not <code>Wrapper</code>s, but borrowed references to the <code>value</code> contained within them.</p>
<p>To avoid leaking private data, if <code>Container#values</code> is public then <code>InspectingIterator</code> must also be public. This, coupled with the need to implement custom iterators may make the approach unsuitable in some situations. At the same time, iterator delegation is the only solution in some cases such as returning an inaccessible iterator from a trait method without boxing.</p>
<p>Several examples combining <code>Iterator</code> delegation with inspection can be found in <a href="https://crates.io/crates/gamma">Gamma</a>, a crate providing primitives for working with graphs. In particular, see <a href="https://docs.rs/gamma/0.5.0/gamma/graph/trait.Graph.html#implementors">the implementors of <code>Graph</code></a>.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Iterators are ubiquitous in Rust and extremely versatile. Many problems can be solved by simply returning an iterator produced elsewhere. But sometimes getting this to work will require more. The approaches presented here cover most commonly-encountered cases.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Depth-First 2024 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
