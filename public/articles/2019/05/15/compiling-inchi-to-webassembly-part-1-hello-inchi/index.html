<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Compiling InChI to WebAssembly Part 1: Hello InChI | Depth-First</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="A step-by-step approach to building WebAssembly from an existing C project.">
    <meta name="generator" content="Hugo 0.139.4">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/articles/2019/05/15/compiling-inchi-to-webassembly-part-1-hello-inchi/">
    

    <meta property="og:url" content="http://localhost:1313/articles/2019/05/15/compiling-inchi-to-webassembly-part-1-hello-inchi/">
  <meta property="og:site_name" content="Depth-First">
  <meta property="og:title" content="Compiling InChI to WebAssembly Part 1: Hello InChI">
  <meta property="og:description" content="A step-by-step approach to building WebAssembly from an existing C project.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-05-15T13:30:00+00:00">
    <meta property="article:modified_time" content="2019-05-15T13:30:00+00:00">

  <meta itemprop="name" content="Compiling InChI to WebAssembly Part 1: Hello InChI">
  <meta itemprop="description" content="A step-by-step approach to building WebAssembly from an existing C project.">
  <meta itemprop="datePublished" content="2019-05-15T13:30:00+00:00">
  <meta itemprop="dateModified" content="2019-05-15T13:30:00+00:00">
  <meta itemprop="wordCount" content="1772">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Compiling InChI to WebAssembly Part 1: Hello InChI">
  <meta name="twitter:description" content="A step-by-step approach to building WebAssembly from an existing C project.">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Depth-First
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Compiling InChI to WebAssembly Part 1: Hello InChI</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-05-15T13:30:00Z">May 15, 2019</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>As noted in a <a href="/articles/2019/05/01/javascript-for-cheminformatics-part-2/">recent article</a>, WebAssembly adds a powerful new suite of tools to the Web development workshop. In particular, WebAssembly clears a path to running software written in arbitrary languages within a Web browser securely, and at near native speeds. Unfortunately, taking advantage of this new potential is non-trivial given that it requires expertise in both Web technologies and traditional build systems.</p>
<p>This article, the first in a series, shows how to compile a real-world C codebase to WebAssembly. Specific problems and general solutions are highlighted. In the end, the entire process will reveal itself to be much simpler than it might appear on the surface.</p>
<p>This first installment will show how to create an HTML page and associated assets that rather boringly runs the <code>main</code> InChI function and then promptly exits. Future installments will grow a dedicated library that can be called from a JavaScript running in the browser or Node.js.</p>
<h1 id="about-webassembly">About WebAssembly</h1>
<p>The <a href="https://webassembly.org">WebAssembly standard</a> describes a binary instruction format that has been implemented by all major browsers since 2017. The aim of this standard is to provide a browser-embeddable, universal compile target that executes at native speed.</p>
<p>The idea of a browser-native universal compile target has been around for a long time. In the late 1990s, Java was viewed by many as the obvious choice. A multitude of mistakes, technical and political, rendered this idea unworkable. In 2013, the <a href="https://johnresig.com/blog/asmjs-javascript-compile-target/">first possible replacement</a> began to take shape the form of <a href="http://asmjs.org">asm.js</a>. Asm.js is an optimizable subset of JavaScript that as the name suggests can be used as a kind of assembly language. Although it executes faster than JavaScript, asm.js suffers from sub-optimal parsing speed and large file size. WebAssembly represents a backward-compatible reformulation of asm.js that can be <a href="https://pspdfkit.com/blog/2018/a-real-world-webassembly-benchmark/">parsed and encoded more efficiently</a>. As such, tooling designed to generate asm.js can be adapted to also produce WebAssembly.</p>
<p>The current iteration of the WebAssembly specification is considered a <a href="https://webassembly.org/docs/mvp/">minimum viable product</a> (MVP) by its creators. As such, many possible features and improvements have been left out for the sake of correctness. With increased traction and stability of the base system, these features and improvements can be expected to appear in WebAssembly.</p>
<h1 id="emscripten">Emscripten</h1>
<!-- raw HTML omitted -->
<p><a href="https://emscripten.org">Emscripten</a> transforms <a href="https://llvm.org">LLVM</a> compiler output to both asm.js and WebAssembly. LLVM enjoys broad support as a compile target, meaning that any language that can be reduced to LLVM can in principle be further compiled to WebAssembly. A few years ago, I <a href="http://metamolecular.com/inchi-js">showed how</a> to compile the InChI chemical identifier software to asm.js using Emscripten. With the more recent support of WebAssembly by all major browsers, it&rsquo;s time to update that work with an exhaustive description of how to compile InChI to WebAssembly.</p>
<h1 id="goals">Goals</h1>
<p>I approached this project with four main goals:</p>
<ol>
<li>Don&rsquo;t modify the InChI source files in any way. Leaving the InChI source pristine means that this dependency can be readily swapped out to maintain compatibility with new releases.</li>
<li>Build a wrapper API written in C. This wrapper must get everything it needs from the InChI sources and must introduce no external dependencies.</li>
<li>Compile the wrapper and InChI dependencies into a single WebAssembly file (<code>*.wasm</code>).</li>
<li>The final result will be one JavaScript file (<code>*.js</code>) and one wasm (<code>*.wasm</code>) dependency.</li>
</ol>
<p>This article focuses on Goal (1), compilation of unmodified InChI source. Subsequent articles will focus on the remaining three goals.</p>
<h1 id="prerequisites">Prerequisites</h1>
<p>The following tutorial assumes you&rsquo;ve <a href="https://emscripten.org/docs/getting_started/downloads.html">installed and activated</a> the latest version of the Emscripten toolchain in your current environment. It also assumes you&rsquo;re running Mac OS, although other unix systems might work as well.</p>
<h1 id="compile-the-native-executable">Compile the Native Executable</h1>
<p>Before attempting to compile to WebAssembly, we need to first understand how to compile a native binary. Emscripten replaces your existing compile toolchain with one capable of producing WebAssembly output. As such, it&rsquo;s very helpful to first develop a method to compile natively before attempting to use Emscripten.</p>
<p>My company maintains an unofficial InChI source code repository <a href="https://github.com/metamolecular/inchi">here</a>. Clone and make it your working directory. Alternatively, <a href="https://www.inchi-trust.org/downloads/">download from the InChI site</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone https://github.com/metamolecular/inchi
</span></span><span style="display:flex;"><span>cd inchi
</span></span><span style="display:flex;"><span>ls
</span></span><span style="display:flex;"><span>INCHI_API  INCHI_BASE INCHI_EXE  LICENCE    README.md  readme.txt
</span></span></code></pre></div><p>Two directories contain the source files we&rsquo;ll need: <code>INCHI_BASE</code>, and <code>INCHI_EXE</code>.</p>
<p>Although the InCHI repository contains makefiles, they&rsquo;re too tightly coupled to be useful for the purpose of cross-compilation. Instead, we&rsquo;ll need to devise a simple way to get the C compiler to build InChI&rsquo;s <code>main</code> function.</p>
<p>In the interest of keeping the InChI repository itself clean, create a <code>build</code> subdirectory and change into it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir build
</span></span><span style="display:flex;"><span>cd build
</span></span></code></pre></div><p><a href="https://halogenandtoast.com/error-driven-development/">Error-driven devlopment</a> is a powerful way to learn new techniques. The idea is to begin with the simplest possible idea, no matter how unlikely to work. Then, using the error messages that result, figure out how to get to the next error. Continue until you either exhaust all errors or paths forward.</p>
<p>The simplest idea would be to invoke the C compiler directly on the file containing InChI&rsquo;s <code>main</code> function. It can be found at <code>INCHI_EXE/inchi-1/src/ichimain.c</code>. Attempting to compile <code>ichimain.c</code> directly gave:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cc <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ../INCHI_EXE/inchi-1/src/ichimain.c
</span></span><span style="display:flex;"><span>../INCHI_EXE/inchi-1/src/ichimain.c:50:10: fatal error: <span style="color:#e6db74">&#39;conio.h&#39;</span> file not found
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &lt;conio.h&gt;</span>
</span></span><span style="display:flex;"><span>         ^~~~~~~~~
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> error generated.
</span></span></code></pre></div><p><code>conio.h</code> is a MS-DOS header. Given that I&rsquo;m compiling on a MacOS system, the error is to be expected. Searching the source for the text &ldquo;<code>conio.h</code>&rdquo; offers a clue. Starting on line 48 of the file <code>INCHI_BASE/src/ichiparm.c</code>, for example, we find:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#ifndef COMPILE_ANSI_ONLY
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;conio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p>This suggests that we can move past the error by setting the <code>COMPILE_ANSI_ONLY</code> flag. This can be accomplished by updating the build command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cc <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ../INCHI_EXE/inchi-1/src/ichimain.c <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DCOMPILE_ANSI_ONLY
</span></span></code></pre></div><p>Doing so generates the new error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>../INCHI_EXE/inchi-1/src/ichimain.c:56:10: fatal error: 
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#39;../../INCHI_BASE/src/mode.h&#39;</span> file not found
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &#34;../../INCHI_BASE/src/mode.h&#34;</span>
</span></span><span style="display:flex;"><span>         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span></span></code></pre></div><p>Now would be a good time to point the compiler to its required headers. Browsing through the <code>INCHI_BASE/src</code> directory reveals it to contain many header files. We can include them with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cc <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ../INCHI_EXE/inchi-1/src/ichimain.c <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -I../INCHI_BASE/src <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DCOMPILE_ANSI_ONLY
</span></span></code></pre></div><p>Again a new error. This time we&rsquo;re notified that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>In file included from ../INCHI_EXE/inchi-1/src/ichimain.c:56:
</span></span><span style="display:flex;"><span>../INCHI_BASE/src/../../INCHI_BASE/src/mode.h:77:6: error: No build target
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">#defined, pls check compiler options...</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">(</span>TARGET_EXE_STANDALONE|TARGET_API_LIB|TARGET_EXE_USING_API|TARGET_LIB_FOR_WINCHI<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>For this build we&rsquo;re targeting an executable. We can let the compiler know about this choice with the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cc <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ../INCHI_EXE/inchi-1/src/ichimain.c <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -I../INCHI_BASE/src <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DCOMPILE_ANSI_ONLY <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DTARGET_EXE_STANDALONE
</span></span></code></pre></div><p>Running the updated command yields another error, but this time more cryptic than before:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>...<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span> warnings generated.
</span></span><span style="display:flex;"><span>Undefined symbols <span style="color:#66d9ef">for</span> architecture x86_64:
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_FreeAllINChIArrays&#34;</span>, referenced from:
</span></span><span style="display:flex;"><span>      _ProcessSingleInputFile in ichimain-787c41.o
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>...<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>The warning <code>Undefined symbols for architecture</code> means that the compiler failed to locate required functions or data structures. We&rsquo;ve already included the header files from <code>INCH_BASE/src</code> but we haven&rsquo;t tried to compile any of the implementation files. We can fix that with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cc <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ../INCHI_EXE/inchi-1/src/ichimain.c <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ../INCHI_BASE/src/*.c <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -I../INCHI_BASE/src <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DCOMPILE_ANSI_ONLY <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DTARGET_EXE_STANDALONE
</span></span></code></pre></div><p>No errors! Listing the contents of the working directory yields a new file, <code>a.out</code>. This is the binary executable. For now, delete it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>rm a.out
</span></span></code></pre></div><p>We&rsquo;re almost there. All that remains is to generate a binary with a more descriptive name than <code>a.out</code>. This can be accomplished with the following change:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cc <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ../INCHI_EXE/inchi-1/src/ichimain.c <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ../INCHI_BASE/src/*.c <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -I../INCHI_BASE/src <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DCOMPILE_ANSI_ONLY <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DTARGET_EXE_STANDALONE <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -o inchi
</span></span></code></pre></div><p>This produces an executable called <code>inchi</code> in the working directory. It can be executed with the command <code>./inchi</code>. Verify that it produces the expected output by saving a molfile called <code>example.mol</code> to the working directory. Then execute the command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./inchi example.mol
</span></span><span style="display:flex;"><span>InChI version 1, Software v. 1.05 <span style="color:#f92672">(</span>inchi-1 executable<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Linux Build of May <span style="color:#ae81ff">13</span> <span style="color:#ae81ff">2019</span> 09:38:13
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>... more output<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>My <code>example.mol</code> file encoding benzene yielded the following output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat example.mol.txt
</span></span><span style="display:flex;"><span>* Input_File: <span style="color:#e6db74">&#34;example.mol&#34;</span>
</span></span><span style="display:flex;"><span>Structure: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>InChI<span style="color:#f92672">=</span>1S/C6H6/c1-2-4-6-5-3-1/h1-6H
</span></span><span style="display:flex;"><span>AuxInfo<span style="color:#f92672">=</span>1/0/N:1,2,6,3,5,4/E:<span style="color:#f92672">(</span>1,2,3,4,5,6<span style="color:#f92672">)</span>/rA:6nCCCCCC/rB:d1;s2;d3;s4;s1d5;/rC:60.6483,-42.3537,0;69.3086,-47.3537,0;77.9689,-42.3537,0;77.9689,-32.3537,0;69.3086,-27.3537,0;60.6483,-32.3537,0;
</span></span></code></pre></div><h1 id="compile-inchi-to-webassembly">Compile InChI to WebAssembly</h1>
<p>Having developed a command for compiling InChI using using the native compiler puts us in excellent position to cross-compile to WebAssembly. Be sure the Emscripten toolchain is <a href="https://emscripten.org/docs/getting_started/downloads.html">installed and activated in your current shell</a>. Then simply change the command (from <code>cc</code> to <code>emcc</code>) and destination (<code>inchi</code> to <code>inchi.html</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>emcc <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -I../INCHI_BASE/src <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ../INCHI_BASE/src/*.c <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ../INCHI_EXE/inchi-1/src/ichimain.c <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DCOMPILE_ANSI_ONLY <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DTARGET_EXE_STANDALONE <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -o inchi.html
</span></span></code></pre></div><p>On MacOS you&rsquo;re likely to see the following error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>../INCHI_BASE/src/util.c:1562:33: error: implicit declaration of <span style="color:#66d9ef">function</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#39;__isascii&#39;</span> is invalid in C99 <span style="color:#f92672">[</span>-Werror,-Wimplicit-function-declaration<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span> i <span style="color:#f92672">=</span> 0; i &lt; len <span style="color:#f92672">&amp;&amp;</span> __isascii<span style="color:#f92672">(</span> p<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> isspace<span style="color:#f92672">(</span> p<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">)</span>; i++ <span style="color:#f92672">)</span>
</span></span></code></pre></div><p><a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/isascii-isascii-iswascii"><code>__isascii</code></a> is yet another a Windows-only API used by InChI. It&rsquo;s far from clear why the IUPAC team included multiple platform-specific dependencies by default in its build. Fortunately, it also provided workarounds.</p>
<p>Searching the source tree for the text <code>__isascii</code> reveals a hint in <code>INCHI_BASE/src/util.c</code>. Starting on line 47, we find:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#if defined(COMPILE_ANSI_ONLY) &amp;&amp; defined(__APPLE__)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/*    For build under OSX, advice from Burt Leland */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;ichicomp.h&#34;    /* Needed for __isascii define */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p>Adding the <code>__APPLE__</code> flag gives the following command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>emcc <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -I../INCHI_BASE/src <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ../INCHI_BASE/src/*.c <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ../INCHI_EXE/inchi-1/src/ichimain.c <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DCOMPILE_ANSI_ONLY <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DTARGET_EXE_STANDALONE <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -D__APPLE__ <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -o inchi.html
</span></span></code></pre></div><p>Executing this command produces three files: an HTML file that can be run in a browser; a JavaScript bootstrap file; and a wasm file containing the InChI source compiled to WebAssembly.</p>
<p>Success!</p>
<h1 id="testing-in-a-browser">Testing in a Browser</h1>
<p>At this point we&rsquo;re ready to test the generated WebAssembly. If you open the <code>inchi.html</code> file into your browser directly, you&rsquo;re likely to be greeted with a hung progress spinner and something like the following error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>both async and sync fetching of the wasm failed
</span></span></code></pre></div><p>The problem is that security constraints prevent modern browsers from opening resource files from pages loaded with the <code>file:///</code> protocol. We can work around this limitation by running a web server. A convenient lightweight server available on most systems is Python&rsquo;s <a href="https://docs.python.org/2/library/simplehttpserver.html">SimpleHTTPServer</a>. Execute it in your working directory with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>python -m SimpleHTTPServer
</span></span></code></pre></div><p>This server allows us to test the WebAssembly output by opening the <code>inchi.html</code> file. For example, if your server runs on localhost:8000, point your browser to <a href="http://localhost:8000/inchi.html">http://localhost:8000/inchi.html</a>. Doing so should yield the following window:</p>
<p><img src="/images/posts/20190515/inchi-html.png" alt="InChI HTML"></p>
<p>There it is: InChI running in the browser!</p>
<p>But we&rsquo;re still not done yet. Although the <code>main</code> function has been called, no arguments were passed and the runtime promptly exited. InChI&rsquo;s help output has been displayed but nothing else. Much more interesting would be to obtain an InChI identifier from an arbitrary molfile interactively from the browser console or a JavaScript program.</p>
<h1 id="conclusion">Conclusion</h1>
<p>This article presents a step-by-step procedure for cross-compiling a representative C codebase to WebAssembly using Emscripten. Although there are a few small complications to pay attention to, the procedure for generating a native binary looks almost identical to the one for generating WebAssembly. As such, the instructions here should serve as a model for cross-compiling other C codebases.</p>
<p>For the moment, the result isn&rsquo;t much to look at. The next post in this series will show how to create a full-blown JavaScript API that generates InChIs from molfile strings.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Depth-First 2024 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
