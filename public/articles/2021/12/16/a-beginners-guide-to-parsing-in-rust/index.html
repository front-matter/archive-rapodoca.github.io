<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>A Beginner&#39;s Guide to Parsing in Rust | Depth-First</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Using a flexible system for writing custom parsers in Rust and other languages.">
    <meta name="generator" content="Hugo 0.139.4">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/articles/2021/12/16/a-beginners-guide-to-parsing-in-rust/">
    

    <meta property="og:url" content="http://localhost:1313/articles/2021/12/16/a-beginners-guide-to-parsing-in-rust/">
  <meta property="og:site_name" content="Depth-First">
  <meta property="og:title" content="A Beginner&#39;s Guide to Parsing in Rust">
  <meta property="og:description" content="Using a flexible system for writing custom parsers in Rust and other languages.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2021-12-16T18:00:00+00:00">
    <meta property="article:modified_time" content="2021-12-16T18:00:00+00:00">

  <meta itemprop="name" content="A Beginner&#39;s Guide to Parsing in Rust">
  <meta itemprop="description" content="Using a flexible system for writing custom parsers in Rust and other languages.">
  <meta itemprop="datePublished" content="2021-12-16T18:00:00+00:00">
  <meta itemprop="dateModified" content="2021-12-16T18:00:00+00:00">
  <meta itemprop="wordCount" content="2397">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="A Beginner&#39;s Guide to Parsing in Rust">
  <meta name="twitter:description" content="Using a flexible system for writing custom parsers in Rust and other languages.">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Depth-First
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Articles
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">A Beginner&#39;s Guide to Parsing in Rust</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2021-12-16T18:00:00Z">December 16, 2021</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Parsers are crucial for many data processing tasks. Contrary to what appearances might imply, writing a parser from scratch is not difficult given the right starting point. This article presents a flexible system for writing custom parsers for a wide range of languages. It assumes some experience with Rust, but no experience with language theory. More experienced readers might want to skip directly to the <a href="https://crates.io/crates/lyn">Lyn crate</a>.</p>
<h1 id="about-parsers">About Parsers</h1>
<p>Before diving into practical details, it&rsquo;s important to understand what a parser does. For the purposes of this article, a parser transforms a string into a data structure. A parser can be as simple as a bare function, in which case the problem of writing a parser boils down to implementing that function in a meaningful way.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse</span>(string: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>DataStructure, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    todo!(<span style="color:#e6db74">&#34;parse string into DataStructure or Error&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Many variations on this theme are possible. The important point is that a simple function is a fine starting point for a parser.</p>
<h1 id="recursive-descent-parsers">Recursive Descent Parsers</h1>
<p>The kind of parser described in this article is known as a <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser"><em>recursive descent parser</em></a>. Two things are needed to write such a parser: a <em>formal grammar</em> (&ldquo;grammar&rdquo;) and a <em>method</em> for reducing it to code.</p>
<p>A grammar is a tool for defining the set of valid strings in a language. This definition usually takes the form of one or more <em>production rules</em>. A production rule represents a single valid transformation allowed under the grammar.</p>
<p>Production rules themselves are expressed using one of a number of possible <em>matasyntax notations</em>. A popular option is <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">Extended Backusâ€“Naur form</a> (EBNF). As an example, consider a language whose valid strings consist of one or more asterisk characters (e.g., <code>*</code>, <code>**</code>, <code>***</code>, and so on). Let&rsquo;s call it the Star language, which could be defined in EBNF using two production rules:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>&lt;string&gt; ::= &lt;unit&gt;+
</span></span><span style="display:flex;"><span>&lt;unit&gt;   ::= &#34;*&#34;
</span></span></code></pre></div><p>A production rule is composed of two main features: <em>terminals</em> and <em>non-terminals</em>. A terminal is a literal character or character sequence. There is one terminal in the Star language (<code>*</code>). A non-terminal is constructed from terminals and other non-terminals. The name of a non-terminal appears once to the left of an equals operator (<code>::=</code>), and it will usually appear on the right-hand side of one or more production rules. The Star language contains two non-terminals (<code>&lt;string&gt;</code> and <code>&lt;unit&gt;</code>). Quantifiers such as the plus symbol (<code>+</code>, meaning &ldquo;one or more&rdquo;) are allowed and generally have the same meaning as in regular expression systems. As we&rsquo;ll see, this composition of grammar features lends itself well to translation into many programming languages.</p>
<p>A handy, interactive tool for testing EBNF grammars is <a href="https://bnfplayground.pauliankline.com">BNF Playground</a>. Enter your grammar and an input string, and the Playground will tell you whether the string matches the grammar. The Evaluator will also report syntax errors in the grammar itself.</p>
<p>It&rsquo;s not always convenient or desirable to work with formal grammars. Many dialects of &ldquo;EBNF&rdquo; are in use, and the differences are great enough to cause issues with tooling. Then there&rsquo;s the problem of communicating syntax to an audience of mixed technical ability. Fortunately, a graphical alternative exists: <em>railroad diagrams</em>. A railroad diagram serves the same purpose as a production rule, but does so graphically. For example, the formal grammar given above can be expressed with the following railroad diagram. Many more examples can be found in <a href="https://www.json.org/json-en.html">the JSON documentation</a>.</p>
<!-- raw HTML omitted -->
<p>Given a grammar, writing a parser boils down to finding a method to translate each production rule into a function. It&rsquo;s convenient to name these functions after the production rules they express. The parser for the Star language would have two functions named <code>string</code> and <code>unit</code>, respectively. By translating syntax features into programming language control statements, we can arrive at a method to translate the Star grammar into a validating parser.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">string</span>(string: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> state <span style="color:#f92672">=</span> State {
</span></span><span style="display:flex;"><span>        cursor: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>        characters: <span style="color:#a6e22e">string</span>.chars().collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>()
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>unit(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> state) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    state.cursor <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> state.cursor <span style="color:#f92672">==</span> state.characters.len()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">unit</span>(state: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> State) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> state.characters.get(state.cursor) {
</span></span><span style="display:flex;"><span>        Some(character) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">if</span> character <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span><span style="color:#e6db74">&#39;*&#39;</span> {
</span></span><span style="display:flex;"><span>            state.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">State</span> {
</span></span><span style="display:flex;"><span>    cursor: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>    characters: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To test whether a <code>str</code> encodes a member of the Star language, we call the <code>string</code> function. A return value of <code>true</code> indicates membership. Notice that Rust&rsquo;s <code>Boolean</code> type serves as the data structure returned from this parser. This return value can be as simple or complex as you&rsquo;d like.</p>
<p>Grammar and method are connected. Although the topic is too involved for this post, I discuss it in <a href="https://depth-first.com/articles/2019/01/22/scanner-driven-parser-development/"><em>Scanner-Driven Parser Development</em></a>. To recap the most important point, writing a recursive descent parser requires a grammar without left recursion.  Consider the infinite recursion problem involved with translating the following grammar into functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>&lt;string&gt; ::= &lt;string&gt; &lt;unit&gt;
</span></span><span style="display:flex;"><span>&lt;unit&gt;   ::= &#34;*&#34;
</span></span></code></pre></div><p>Fortunately, such grammars can usually be refactored to eliminate left recursion.</p>
<h1 id="scanner">Scanner</h1>
<p>The sample parser for the Star language uses a <code>State</code> instance to keep track of internal state. This is common for function-based parsers. As the example illustrates, it quickly becomes clumsy to burden individual functions with updating the parse state. A better approach is to move that responsibility into the type itself. The result is a <em>scanner</em>.</p>
<p>The <code>State</code> type can be transformed into a <code>Scanner</code> with the addition of some simple methods for accessing and mutating state:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Scanner</span> {
</span></span><span style="display:flex;"><span>    cursor: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>    characters: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Scanner {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(string: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self {
</span></span><span style="display:flex;"><span>            cursor: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>            characters: <span style="color:#a6e22e">string</span>.chars().collect(),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the current cursor. Useful for reporting errors.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cursor</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">usize</span> {
</span></span><span style="display:flex;"><span>        self.cursor
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the next character without advancing the cursor.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// AKA &#34;lookahead&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">peek</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Option<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        self.characters.get(self.cursor)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns true if further progress is not possible.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">is_done</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>        self.cursor <span style="color:#f92672">==</span> self.characters.len()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the next character (if available) and advances the cursor.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">pop</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self.characters.get(self.cursor) {
</span></span><span style="display:flex;"><span>            Some(character) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                self.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Some(character)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            None <span style="color:#f92672">=&gt;</span> None,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now it&rsquo;s possible to refactor <code>string</code> as follows.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">string</span>(string: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> scanner <span style="color:#f92672">=</span> Scanner::new(string);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>unit(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> scanner) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    scanner.cursor() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> state.is_done()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">unit</span>(scanner: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Scanner) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> scanner.peek() {
</span></span><span style="display:flex;"><span>      Some(character) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">if</span> character <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span><span style="color:#e6db74">&#39;*&#39;</span> {
</span></span><span style="display:flex;"><span>          scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="room-for-improvement">Room for Improvement</h1>
<p>Although tucking state manipulation into <code>Scanner</code> cleans things up a bit, it doesn&rsquo;t noticeably affect the structure of the parser code itself. The problem is that the current <code>Scanner</code> API forces mutators and accessors to be applied in separate operations. Given a complex language with many production rules, exposing all of the gruntwork can hide the actual purpose of parser functions. Even worse is the potential for introducing bugs. It&rsquo;s easy to forget to call <code>pop</code> after <code>peek</code>. And the <code>peek</code>/<code>pop</code> sequence is ubiquitous in recursive descent parsers.</p>
<p>What if it were possible to eliminate these problems?</p>
<h1 id="the-take-method">The <code>take</code> Method</h1>
<p>The <code>unit</code> function could be re-written to use a new <code>Scanner</code> method called <code>take</code>. It accepts a character to be compared at the current cursor position. If found, the cursor is advanced and true is returned. Otherwise, false is returned.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">unit</span>(scanner: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Scanner) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    scanner.take(<span style="color:#f92672">&amp;</span><span style="color:#e6db74">&#39;*&#39;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>take</code> method could in turn be implemented by merging the code that would otherwise have been present in the <code>unit</code> function (and similar functions using the <code>peek</code>/<code>pop</code> pattern).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// Returns true if the `target` is found at the current cursor position,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// and advances the cursor.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// Otherwise, returns false leaving the cursor unchanged.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">take</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, target: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">char</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> self.characters.get(self.cursor) {
</span></span><span style="display:flex;"><span>        Some(character) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> target <span style="color:#f92672">==</span> character {
</span></span><span style="display:flex;"><span>                self.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="the-transform-method">The <code>transform</code> Method</h1>
<p>Sometimes a parser requires a 1:1 transformation of a character into some data structure. This pattern can be especially tedious with the <code>peek</code>/<code>pop</code> pattern. Consider a language in which certain symbols translate to an unsigned integer value.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>&lt;value&gt; ::= &#34;$&#34; | &#34;#&#34;
</span></span></code></pre></div><p>The parser would look something like this using <code>peek</code>/<code>pop</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">value</span>(scanner: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Scanner) -&gt; Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> scanner.peek() {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;$&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Some(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;#&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Some(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        _  <span style="color:#f92672">=&gt;</span> None
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>value</code> function could be re-arranged in various ways. But none of them would address the root problem, which is that we want to use a single match statement without littering calls to <code>pop</code> in every branch.</p>
<p>A solution is the <code>transform</code> method, which accepts a callback and returns an optional value.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">value</span>(scanner: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Scanner) -&gt; Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    scanner.transform(<span style="color:#f92672">|</span>character<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> character {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;$&#39;</span> <span style="color:#f92672">=&gt;</span> Some(<span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;#&#39;</span> <span style="color:#f92672">=&gt;</span> Some(<span style="color:#ae81ff">2</span>),
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> None
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Not only is the intent of this code much clearer, but it is also much less error prone. It is also potentially more performant than some alternatives.</p>
<p>The <code>transform</code> method, like the <code>take</code> method, can be implemented by merging the code that would otherwise appear in the parser.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// Invoke `cb` once. If the result is not `None`, return it and advance
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// the cursor. Otherwise, return None and leave the cursor unchanged.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">transform</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self,
</span></span><span style="display:flex;"><span>    cb: <span style="color:#a6e22e">impl</span> FnOnce(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">char</span>) -&gt; Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>) -&gt; Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> self.characters.get(self.cursor) {
</span></span><span style="display:flex;"><span>        Some(input) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> cb(input) {
</span></span><span style="display:flex;"><span>            Some(output) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                self.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Some(output)
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            None <span style="color:#f92672">=&gt;</span> None
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        None <span style="color:#f92672">=&gt;</span> None
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="the-scan-method">The <code>scan</code> Method</h1>
<p>Similar refactorings can be used whenever the appearance of parser function diverges noticeably from its corresponding production rule. Consider the following grammar, which might be used to parse the chemical elements into the appropriate variant of the enum <code>Element</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ebnf" data-lang="ebnf"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#66d9ef">element</span><span style="color:#960050;background-color:#1e0010">&gt;</span> <span style="color:#960050;background-color:#1e0010">::</span><span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#e6db74">&#34;c&#34;</span> | <span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#e6db74">&#34;r&#34;</span><span style="color:#960050;background-color:#1e0010">?</span>
</span></span></code></pre></div><p>The implementation might look something like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Element</span> {
</span></span><span style="display:flex;"><span>    Ac,
</span></span><span style="display:flex;"><span>    B,
</span></span><span style="display:flex;"><span>    Br,
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Error</span> {
</span></span><span style="display:flex;"><span>    Character(<span style="color:#66d9ef">usize</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">element</span>(scanner: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Scanner) -&gt; Result<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>Element<span style="color:#f92672">&gt;</span>, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> scanner.peek() {
</span></span><span style="display:flex;"><span>        Some(<span style="color:#e6db74">&#39;A&#39;</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">match</span> scanner.peek() {
</span></span><span style="display:flex;"><span>                Some(<span style="color:#e6db74">&#39;c&#39;</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                    scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    Ok(Some(Element::Br))
</span></span><span style="display:flex;"><span>                },
</span></span><span style="display:flex;"><span>                _ <span style="color:#f92672">=&gt;</span> Err(Error::Character(scanner.cursor()))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        Some(<span style="color:#e6db74">&#39;B&#39;</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">match</span> scanner.peek() {
</span></span><span style="display:flex;"><span>                Some(<span style="color:#e6db74">&#39;r&#39;</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                    scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    Element::C
</span></span><span style="display:flex;"><span>                },
</span></span><span style="display:flex;"><span>                _ <span style="color:#f92672">=&gt;</span> Element::C
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> Ok(None)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As before, there are several tricks for cleaning this up. The problem is that none of them can address the root problem. We want to write a single match statement that transforms all 100+ two-letter element symbols into its corresponding enum variant â€” without introducing more characters of lookahead or nested <code>match</code> arms.</p>
<p>This problem too can be solved by introducing a new <code>Scanner</code> method, <code>scan</code>. Like <code>transform</code>, <code>scan</code> accepts a closure returning a value that will determine further actions taken. Unlike <code>transform</code>, however, <code>scan</code> is repeatedly called until an exit condition is detected. This makes it possible to transform multi-character sequences with fine precision.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">element</span>(scanner: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Scanner) -&gt; Result<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>Element<span style="color:#f92672">&gt;</span>, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    scanner.scan(<span style="color:#f92672">|</span>symbol<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> symbol {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">=&gt;</span> Some(Action::Require),
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#f92672">=&gt;</span> Some(Action::Request(Element::B)),
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;Br&#34;</span> <span style="color:#f92672">=&gt;</span> Some(Action::Return(Element::Br)),
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> None
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>scan</code> method, like <code>take</code> and <code>transform</code>, was built by factoring out the code that would have otherwise been contained within parser functions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Action</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// If next iteration returns None, return T without advancing
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// the cursor.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    Request(T),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// If the next iteration returns None, return None without advancing
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// the cursor.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    Require,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Immediately advance the cursor and return T.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    Return(T)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">scan</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, cb: <span style="color:#a6e22e">impl</span> Fn(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Option<span style="color:#f92672">&lt;</span>Action<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sequence <span style="color:#f92672">=</span> String::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> require <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> request <span style="color:#f92672">=</span> None;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self.characters.get(self.cursor) {
</span></span><span style="display:flex;"><span>            Some(target) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                sequence.push(<span style="color:#f92672">*</span>target);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">match</span> cb(<span style="color:#f92672">&amp;</span>sequence) {
</span></span><span style="display:flex;"><span>                    Some(Action::Return(result)) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        self.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span> Ok(Some(result))
</span></span><span style="display:flex;"><span>                    },
</span></span><span style="display:flex;"><span>                    Some(Action::Request(result)) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        self.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                        require <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                        request <span style="color:#f92672">=</span> Some(result);
</span></span><span style="display:flex;"><span>                    },
</span></span><span style="display:flex;"><span>                    Some(Action::Require) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        self.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                        require <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                    },
</span></span><span style="display:flex;"><span>                    None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">if</span> require {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span> Err(Error::Character(self.cursor))
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span> Ok(request)
</span></span><span style="display:flex;"><span>                    },
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">if</span> require {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span> Err(Error::EndOfLine)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span> Ok(request)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="lyn-crate">Lyn Crate</h1>
<p><code>Scanner</code> can conveniently be used via the <a href="https://crates.io/crates/lyn">Lyn crate</a>. It will be incorporated into the reference implementation for a <a href="https://depth-first.com/articles/2021/09/22/beyond-smiles/">molecular language</a> I&rsquo;m working on. If you use Lyn in a project I&rsquo;d be very interested in <a href="/about/">hearing from you</a>.</p>
<h1 id="about-parser-generators">About Parser Generators</h1>
<p>As an alternative to writing a recursive descent parser, it&rsquo;s also possible to build a parser directly from a grammar using a <em>parser generator</em>. Many sources give the impression that a parser generator is the only way to parse. Having used a few parser generators, I don&rsquo;t necessarily agree. Some of the downsides of a parser generator include:</p>
<ul>
<li>Awkward code management. A parser generation will often emit source code that must somehow be integrated within a source tree. But being auto-generated, this code can&rsquo;t be managed with any of the usual workflows.</li>
<li>Confusing stack traces. The flow through auto-generated code can be confusing to follow. This makes debugging more difficult than it otherwise might be.</li>
<li>Some parser generators require learning unfamiliar and/or poorly-supported APIs. These are furthermore sometimes specific to a single programming language. So the investment made in them can&rsquo;t necessarily move on when you do.</li>
</ul>
<p>Although parser generators can save effort in the short term, the full extent of the disadvantages often won&rsquo;t become known until some time in the future of a project. For this reason, I recommend trying to write a recursive descent parser or two first, and only then moving on to a parser generator when the advantages of doing so will clearly outweigh the disadvantages.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Recursive descent parsers are straightforward to write given a solid starting point. This article has to painted a picture of what this starting point might look like. Two tools are required: a grammar; and a method for turning its production rules into functions. A scanner is a powerful tool for the latter, allowing the resulting functions of a parser to closely resemble the corresponding production rule. A scanner can be as simple or complex as your language requires. Three examples demonstrated how to move repetitive, bug-prone code into the scanner for cleaner, simpler parsers. The <a href="https://crates.io/crates/lyn">Lyn crate</a> offers a fully-functional scanner.</p>
<h1 id="acknowledgement">Acknowledgement</h1>
<p><a href="https://petermalmgren.com/">Peter Malmgren&rsquo;s</a> article <a href="https://petermalmgren.com/three-rust-parsers/"><em>Implementing a calculator parser in Rust</em></a> helped crystallize some of my ideas about explaining recursive descent parsers.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Depth-First 2024 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
