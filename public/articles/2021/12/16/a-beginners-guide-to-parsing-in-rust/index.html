<!DOCTYPE html>
<html lang="en-us" dir="ltr" class="scroll-smooth" data-default-appearance="light"
  data-auto-appearance="true"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  
  <meta http-equiv="content-language" content="en-us" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  
  <title>A Beginner&#39;s Guide to Parsing in Rust &middot; Depth-First</title>
  <meta name="title" content="A Beginner&#39;s Guide to Parsing in Rust &middot; Depth-First" />
  
  <meta name="description" content="Using a flexible system for writing custom parsers in Rust and other languages." />
  
  
  
  <link rel="canonical" href="http://localhost:1313/articles/2021/12/16/a-beginners-guide-to-parsing-in-rust/" />
  
  
  
  
  
  
  
  
  
  
  <link type="text/css" rel="stylesheet" href="/css/main.bundle.min.e27868ab1485f7ed7b06b122b4980bd38b19526eb8f7de885181204d28f04a0c47e9c334eff19a06c0278eb2ff8415b983a5d0fb80fd6b5680c926457cc61c57.css"
    integrity="sha512-4nhoqxSF9&#43;17BrEitJgL04sZUm64996IUYEgTSjwSgxH6cM07/GaBsAnjrL/hBW5g6XQ&#43;4D9a1aAySZFfMYcVw==" />
  
  
  <script type="text/javascript" src="/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js"
    integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj&#43;e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script>
  
  
  
  
  
  
  
  
  
  
  
  <script defer type="text/javascript" id="script-bundle" src="/js/main.bundle.min.c178288131a2f1ad46910438db47ac5f7e1c48cf949e49f6dc3310c8ec9660e23fe505805eba4e2e73711335808500360d773a2b64322feb35df52856edca286.js"
    integrity="sha512-wXgogTGi8a1GkQQ420esX34cSM&#43;Unkn23DMQyOyWYOI/5QWAXrpOLnNxEzWAhQA2DXc6K2QyL&#43;s131KFbtyihg==" data-copy="" data-copied=""></script>
  
  
  
  <script src="/lib/zoom/zoom.min.37d2094687372da3f7343a221a470f6b8806f7891aa46a5a03966af7f0ebd38b9fe536cb154e6ad28f006d184b294525a7c4054b6bbb4be62d8b453b42db99bd.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S&#43;Yti0U7QtuZvQ=="></script>
  
  
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
  <link rel="manifest" href="/site.webmanifest" />
  
  
  
  
  
  
  
  
  <meta property="og:url" content="http://localhost:1313/articles/2021/12/16/a-beginners-guide-to-parsing-in-rust/">
  <meta property="og:site_name" content="Depth-First">
  <meta property="og:title" content="A Beginner&#39;s Guide to Parsing in Rust">
  <meta property="og:description" content="Using a flexible system for writing custom parsers in Rust and other languages.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-12-16T18:00:00+00:00">
    <meta property="article:modified_time" content="2021-12-16T18:00:00+00:00">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="A Beginner&#39;s Guide to Parsing in Rust">
  <meta name="twitter:description" content="Using a flexible system for writing custom parsers in Rust and other languages.">

  
  <script type="application/ld+json">
  [{
    "@context": "https://schema.org",
    "@type": "Article",
    "articleSection": "Posts",
    "name": "A Beginner\u0027s Guide to Parsing in Rust",
    "headline": "A Beginner\u0027s Guide to Parsing in Rust",
    
    "abstract": "Using a flexible system for writing custom parsers in Rust and other languages.",
    "inLanguage": "en-us",
    "url" : "http:\/\/localhost:1313\/articles\/2021\/12\/16\/a-beginners-guide-to-parsing-in-rust\/",
    "author" : {
      "@type": "Person",
      "name": ""
    },
    "copyrightYear": "2021",
    "dateCreated": "2021-12-16T18:00:00\u002b00:00",
    "datePublished": "2021-12-16T18:00:00\u002b00:00",
    
    "dateModified": "2021-12-16T18:00:00\u002b00:00",
    
    
    
    "mainEntityOfPage": "true",
    "wordCount": "2408"
  }]
  </script>


  
  
  
  
  

<script src="/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js" integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj&#43;KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script>






















  
  



  
  
  <meta name="theme-color"/>
  
  
</head>
<body
  class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600">
  <div id="the-top" class="absolute flex self-center">
    <a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600"
      href="#main-content"><span
        class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>Skip to main content</a>
  </div>
  
  
  <div style="padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px"
    class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start space-x-3">
    
    <div class="flex flex-1 items-center justify-between">
        <nav class="flex space-x-3">

            
            <a href="/" class="text-base font-medium text-gray-500 hover:text-gray-900">Depth-First</a>
            

        </nav>
        <nav class="hidden md:flex items-center space-x-5 md:ml-12 h-12">

            

            


            
            <button id="search-button" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            


            
            
            <div
                class="ltr:mr-14 rtl:ml-14 flex items-center">
                <button id="appearance-switcher" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400">
                    <div class="flex items-center justify-center dark:hidden">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                    </div>
                    <div class="items-center justify-center hidden dark:flex">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                    </div>
                </button>
            </div>
            

        </nav>
        <div class="flex md:hidden items-center space-x-5 md:ml-12 h-12">

            <span></span>

            


            
            <button id="search-button-mobile" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            

            
            
            <button id="appearance-switcher-mobile" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400" style="margin-right:5px">
                <div class="flex items-center justify-center dark:hidden">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                </div>
                <div class="items-center justify-center hidden dark:flex">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                </div>
            </button>
            

        </div>
    </div>
    <div class="-my-2 -mr-2 md:hidden">

        <label id="menu-button" class="block">
            

            </div>
        </label>
    </div>
</div>





  
  <div class="relative flex flex-col grow">
    <main id="main-content" class="grow">
      


<article>
  

  <header id="single_header" class="mt-5 max-w-prose">
    
    <h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
      A Beginner's Guide to Parsing in Rust
    </h1>
    <div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden">
      





  
  







  





  



  













<div class="flex flex-row flex-wrap items-center">
  
  
  <time datetime="2021-12-16T18:00:00&#43;00:00">December 16, 2021</time><span class="px-2 text-primary-500">&middot;</span><span>2408 words</span><span class="px-2 text-primary-500">&middot;</span><span title="Reading time">12 mins</span>
  

  
  
</div>








    </div>

    
    
    
    
    

    

    
      
      
        
        
<div class="flex author">
  
  <div class="place-self-center">
    
    
    <div class="text-2xl sm:text-lg">
</div>
  </div>
</div>

      

      

      
      <div class="mb-5"></div>
      

    

  </header>
  
  <section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row">
    
    

      <div class="min-w-0 min-h-0 max-w-fit">
        
        


        <div class="article-content max-w-prose mb-20">
          <p>Parsers are crucial for many data processing tasks. Contrary to what appearances might imply, writing a parser from scratch is not difficult given the right starting point. This article presents a flexible system for writing custom parsers for a wide range of languages. It assumes some experience with Rust, but no experience with language theory. More experienced readers might want to skip directly to the <a href="https://crates.io/crates/lyn" target="_blank">Lyn crate</a>.</p>


<h1 class="relative group">About Parsers 
    <div id="about-parsers" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#about-parsers" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>Before diving into practical details, it&rsquo;s important to understand what a parser does. For the purposes of this article, a parser transforms a string into a data structure. A parser can be as simple as a bare function, in which case the problem of writing a parser boils down to implementing that function in a meaningful way.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse</span>(string: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>DataStructure, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    todo!(<span style="color:#e6db74">&#34;parse string into DataStructure or Error&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Many variations on this theme are possible. The important point is that a simple function is a fine starting point for a parser.</p>


<h1 class="relative group">Recursive Descent Parsers 
    <div id="recursive-descent-parsers" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#recursive-descent-parsers" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>The kind of parser described in this article is known as a <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" target="_blank"><em>recursive descent parser</em></a>. Two things are needed to write such a parser: a <em>formal grammar</em> (&ldquo;grammar&rdquo;) and a <em>method</em> for reducing it to code.</p>
<p>A grammar is a tool for defining the set of valid strings in a language. This definition usually takes the form of one or more <em>production rules</em>. A production rule represents a single valid transformation allowed under the grammar.</p>
<p>Production rules themselves are expressed using one of a number of possible <em>matasyntax notations</em>. A popular option is <a href="https://en.wikipedia.org/wiki/Extended_Backus%e2%80%93Naur_form" target="_blank">Extended Backusâ€“Naur form</a> (EBNF). As an example, consider a language whose valid strings consist of one or more asterisk characters (e.g., <code>*</code>, <code>**</code>, <code>***</code>, and so on). Let&rsquo;s call it the Star language, which could be defined in EBNF using two production rules:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>&lt;string&gt; ::= &lt;unit&gt;+
</span></span><span style="display:flex;"><span>&lt;unit&gt;   ::= &#34;*&#34;
</span></span></code></pre></div><p>A production rule is composed of two main features: <em>terminals</em> and <em>non-terminals</em>. A terminal is a literal character or character sequence. There is one terminal in the Star language (<code>*</code>). A non-terminal is constructed from terminals and other non-terminals. The name of a non-terminal appears once to the left of an equals operator (<code>::=</code>), and it will usually appear on the right-hand side of one or more production rules. The Star language contains two non-terminals (<code>&lt;string&gt;</code> and <code>&lt;unit&gt;</code>). Quantifiers such as the plus symbol (<code>+</code>, meaning &ldquo;one or more&rdquo;) are allowed and generally have the same meaning as in regular expression systems. As we&rsquo;ll see, this composition of grammar features lends itself well to translation into many programming languages.</p>
<p>A handy, interactive tool for testing EBNF grammars is <a href="https://bnfplayground.pauliankline.com" target="_blank">BNF Playground</a>. Enter your grammar and an input string, and the Playground will tell you whether the string matches the grammar. The Evaluator will also report syntax errors in the grammar itself.</p>
<p>It&rsquo;s not always convenient or desirable to work with formal grammars. Many dialects of &ldquo;EBNF&rdquo; are in use, and the differences are great enough to cause issues with tooling. Then there&rsquo;s the problem of communicating syntax to an audience of mixed technical ability. Fortunately, a graphical alternative exists: <em>railroad diagrams</em>. A railroad diagram serves the same purpose as a production rule, but does so graphically. For example, the formal grammar given above can be expressed with the following railroad diagram. Many more examples can be found in <a href="https://www.json.org/json-en.html" target="_blank">the JSON documentation</a>.</p>
<!-- raw HTML omitted -->
<p>Given a grammar, writing a parser boils down to finding a method to translate each production rule into a function. It&rsquo;s convenient to name these functions after the production rules they express. The parser for the Star language would have two functions named <code>string</code> and <code>unit</code>, respectively. By translating syntax features into programming language control statements, we can arrive at a method to translate the Star grammar into a validating parser.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">string</span>(string: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> state <span style="color:#f92672">=</span> State {
</span></span><span style="display:flex;"><span>        cursor: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>        characters: <span style="color:#a6e22e">string</span>.chars().collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>()
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>unit(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> state) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    state.cursor <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> state.cursor <span style="color:#f92672">==</span> state.characters.len()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">unit</span>(state: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> State) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> state.characters.get(state.cursor) {
</span></span><span style="display:flex;"><span>        Some(character) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">if</span> character <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span><span style="color:#e6db74">&#39;*&#39;</span> {
</span></span><span style="display:flex;"><span>            state.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">State</span> {
</span></span><span style="display:flex;"><span>    cursor: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>    characters: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To test whether a <code>str</code> encodes a member of the Star language, we call the <code>string</code> function. A return value of <code>true</code> indicates membership. Notice that Rust&rsquo;s <code>Boolean</code> type serves as the data structure returned from this parser. This return value can be as simple or complex as you&rsquo;d like.</p>
<p>Grammar and method are connected. Although the topic is too involved for this post, I discuss it in <a href="https://depth-first.com/articles/2019/01/22/scanner-driven-parser-development/" target="_blank"><em>Scanner-Driven Parser Development</em></a>. To recap the most important point, writing a recursive descent parser requires a grammar without left recursion.  Consider the infinite recursion problem involved with translating the following grammar into functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>&lt;string&gt; ::= &lt;string&gt; &lt;unit&gt;
</span></span><span style="display:flex;"><span>&lt;unit&gt;   ::= &#34;*&#34;
</span></span></code></pre></div><p>Fortunately, such grammars can usually be refactored to eliminate left recursion.</p>


<h1 class="relative group">Scanner 
    <div id="scanner" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#scanner" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>The sample parser for the Star language uses a <code>State</code> instance to keep track of internal state. This is common for function-based parsers. As the example illustrates, it quickly becomes clumsy to burden individual functions with updating the parse state. A better approach is to move that responsibility into the type itself. The result is a <em>scanner</em>.</p>
<p>The <code>State</code> type can be transformed into a <code>Scanner</code> with the addition of some simple methods for accessing and mutating state:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Scanner</span> {
</span></span><span style="display:flex;"><span>    cursor: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>    characters: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Scanner {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(string: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self {
</span></span><span style="display:flex;"><span>            cursor: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>            characters: <span style="color:#a6e22e">string</span>.chars().collect(),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the current cursor. Useful for reporting errors.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cursor</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">usize</span> {
</span></span><span style="display:flex;"><span>        self.cursor
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the next character without advancing the cursor.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// AKA &#34;lookahead&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">peek</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Option<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        self.characters.get(self.cursor)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns true if further progress is not possible.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">is_done</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>        self.cursor <span style="color:#f92672">==</span> self.characters.len()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the next character (if available) and advances the cursor.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">pop</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self.characters.get(self.cursor) {
</span></span><span style="display:flex;"><span>            Some(character) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                self.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Some(character)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            None <span style="color:#f92672">=&gt;</span> None,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now it&rsquo;s possible to refactor <code>string</code> as follows.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">string</span>(string: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> scanner <span style="color:#f92672">=</span> Scanner::new(string);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>unit(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> scanner) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    scanner.cursor() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> state.is_done()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">unit</span>(scanner: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Scanner) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> scanner.peek() {
</span></span><span style="display:flex;"><span>      Some(character) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">if</span> character <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span><span style="color:#e6db74">&#39;*&#39;</span> {
</span></span><span style="display:flex;"><span>          scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

<h1 class="relative group">Room for Improvement 
    <div id="room-for-improvement" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#room-for-improvement" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>Although tucking state manipulation into <code>Scanner</code> cleans things up a bit, it doesn&rsquo;t noticeably affect the structure of the parser code itself. The problem is that the current <code>Scanner</code> API forces mutators and accessors to be applied in separate operations. Given a complex language with many production rules, exposing all of the gruntwork can hide the actual purpose of parser functions. Even worse is the potential for introducing bugs. It&rsquo;s easy to forget to call <code>pop</code> after <code>peek</code>. And the <code>peek</code>/<code>pop</code> sequence is ubiquitous in recursive descent parsers.</p>
<p>What if it were possible to eliminate these problems?</p>


<h1 class="relative group">The <code>take</code> Method 
    <div id="the-take-method" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#the-take-method" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>The <code>unit</code> function could be re-written to use a new <code>Scanner</code> method called <code>take</code>. It accepts a character to be compared at the current cursor position. If found, the cursor is advanced and true is returned. Otherwise, false is returned.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">unit</span>(scanner: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Scanner) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    scanner.take(<span style="color:#f92672">&amp;</span><span style="color:#e6db74">&#39;*&#39;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>take</code> method could in turn be implemented by merging the code that would otherwise have been present in the <code>unit</code> function (and similar functions using the <code>peek</code>/<code>pop</code> pattern).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// Returns true if the `target` is found at the current cursor position,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// and advances the cursor.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// Otherwise, returns false leaving the cursor unchanged.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">take</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, target: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">char</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> self.characters.get(self.cursor) {
</span></span><span style="display:flex;"><span>        Some(character) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> target <span style="color:#f92672">==</span> character {
</span></span><span style="display:flex;"><span>                self.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

<h1 class="relative group">The <code>transform</code> Method 
    <div id="the-transform-method" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#the-transform-method" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>Sometimes a parser requires a 1:1 transformation of a character into some data structure. This pattern can be especially tedious with the <code>peek</code>/<code>pop</code> pattern. Consider a language in which certain symbols translate to an unsigned integer value.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>&lt;value&gt; ::= &#34;$&#34; | &#34;#&#34;
</span></span></code></pre></div><p>The parser would look something like this using <code>peek</code>/<code>pop</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">value</span>(scanner: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Scanner) -&gt; Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> scanner.peek() {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;$&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Some(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;#&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Some(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        _  <span style="color:#f92672">=&gt;</span> None
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>value</code> function could be re-arranged in various ways. But none of them would address the root problem, which is that we want to use a single match statement without littering calls to <code>pop</code> in every branch.</p>
<p>A solution is the <code>transform</code> method, which accepts a callback and returns an optional value.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">value</span>(scanner: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Scanner) -&gt; Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    scanner.transform(<span style="color:#f92672">|</span>character<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> character {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;$&#39;</span> <span style="color:#f92672">=&gt;</span> Some(<span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;#&#39;</span> <span style="color:#f92672">=&gt;</span> Some(<span style="color:#ae81ff">2</span>),
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> None
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Not only is the intent of this code much clearer, but it is also much less error prone. It is also potentially more performant than some alternatives.</p>
<p>The <code>transform</code> method, like the <code>take</code> method, can be implemented by merging the code that would otherwise appear in the parser.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// Invoke `cb` once. If the result is not `None`, return it and advance
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// the cursor. Otherwise, return None and leave the cursor unchanged.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">transform</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self,
</span></span><span style="display:flex;"><span>    cb: <span style="color:#a6e22e">impl</span> FnOnce(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">char</span>) -&gt; Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>) -&gt; Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> self.characters.get(self.cursor) {
</span></span><span style="display:flex;"><span>        Some(input) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> cb(input) {
</span></span><span style="display:flex;"><span>            Some(output) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                self.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Some(output)
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            None <span style="color:#f92672">=&gt;</span> None
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        None <span style="color:#f92672">=&gt;</span> None
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

<h1 class="relative group">The <code>scan</code> Method 
    <div id="the-scan-method" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#the-scan-method" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>Similar refactorings can be used whenever the appearance of parser function diverges noticeably from its corresponding production rule. Consider the following grammar, which might be used to parse the chemical elements into the appropriate variant of the enum <code>Element</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ebnf" data-lang="ebnf"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#66d9ef">element</span><span style="color:#960050;background-color:#1e0010">&gt;</span> <span style="color:#960050;background-color:#1e0010">::</span><span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#e6db74">&#34;c&#34;</span> | <span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#e6db74">&#34;r&#34;</span><span style="color:#960050;background-color:#1e0010">?</span>
</span></span></code></pre></div><p>The implementation might look something like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Element</span> {
</span></span><span style="display:flex;"><span>    Ac,
</span></span><span style="display:flex;"><span>    B,
</span></span><span style="display:flex;"><span>    Br,
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Error</span> {
</span></span><span style="display:flex;"><span>    Character(<span style="color:#66d9ef">usize</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">element</span>(scanner: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Scanner) -&gt; Result<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>Element<span style="color:#f92672">&gt;</span>, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> scanner.peek() {
</span></span><span style="display:flex;"><span>        Some(<span style="color:#e6db74">&#39;A&#39;</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">match</span> scanner.peek() {
</span></span><span style="display:flex;"><span>                Some(<span style="color:#e6db74">&#39;c&#39;</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                    scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    Ok(Some(Element::Br))
</span></span><span style="display:flex;"><span>                },
</span></span><span style="display:flex;"><span>                _ <span style="color:#f92672">=&gt;</span> Err(Error::Character(scanner.cursor()))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        Some(<span style="color:#e6db74">&#39;B&#39;</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">match</span> scanner.peek() {
</span></span><span style="display:flex;"><span>                Some(<span style="color:#e6db74">&#39;r&#39;</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                    scanner.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    Element::C
</span></span><span style="display:flex;"><span>                },
</span></span><span style="display:flex;"><span>                _ <span style="color:#f92672">=&gt;</span> Element::C
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> Ok(None)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As before, there are several tricks for cleaning this up. The problem is that none of them can address the root problem. We want to write a single match statement that transforms all 100+ two-letter element symbols into its corresponding enum variant â€” without introducing more characters of lookahead or nested <code>match</code> arms.</p>
<p>This problem too can be solved by introducing a new <code>Scanner</code> method, <code>scan</code>. Like <code>transform</code>, <code>scan</code> accepts a closure returning a value that will determine further actions taken. Unlike <code>transform</code>, however, <code>scan</code> is repeatedly called until an exit condition is detected. This makes it possible to transform multi-character sequences with fine precision.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">element</span>(scanner: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Scanner) -&gt; Result<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>Element<span style="color:#f92672">&gt;</span>, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    scanner.scan(<span style="color:#f92672">|</span>symbol<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> symbol {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">=&gt;</span> Some(Action::Require),
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#f92672">=&gt;</span> Some(Action::Request(Element::B)),
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;Br&#34;</span> <span style="color:#f92672">=&gt;</span> Some(Action::Return(Element::Br)),
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> None
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>scan</code> method, like <code>take</code> and <code>transform</code>, was built by factoring out the code that would have otherwise been contained within parser functions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Action</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// If next iteration returns None, return T without advancing
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// the cursor.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    Request(T),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// If the next iteration returns None, return None without advancing
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// the cursor.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    Require,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Immediately advance the cursor and return T.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    Return(T)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">scan</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, cb: <span style="color:#a6e22e">impl</span> Fn(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Option<span style="color:#f92672">&lt;</span>Action<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>, Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sequence <span style="color:#f92672">=</span> String::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> require <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> request <span style="color:#f92672">=</span> None;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self.characters.get(self.cursor) {
</span></span><span style="display:flex;"><span>            Some(target) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                sequence.push(<span style="color:#f92672">*</span>target);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">match</span> cb(<span style="color:#f92672">&amp;</span>sequence) {
</span></span><span style="display:flex;"><span>                    Some(Action::Return(result)) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        self.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span> Ok(Some(result))
</span></span><span style="display:flex;"><span>                    },
</span></span><span style="display:flex;"><span>                    Some(Action::Request(result)) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        self.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                        require <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                        request <span style="color:#f92672">=</span> Some(result);
</span></span><span style="display:flex;"><span>                    },
</span></span><span style="display:flex;"><span>                    Some(Action::Require) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        self.cursor <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                        require <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                    },
</span></span><span style="display:flex;"><span>                    None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">if</span> require {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span> Err(Error::Character(self.cursor))
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span> Ok(request)
</span></span><span style="display:flex;"><span>                    },
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">if</span> require {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span> Err(Error::EndOfLine)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span> Ok(request)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

<h1 class="relative group">Lyn Crate 
    <div id="lyn-crate" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#lyn-crate" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p><code>Scanner</code> can conveniently be used via the <a href="https://crates.io/crates/lyn" target="_blank">Lyn crate</a>. It will be incorporated into the reference implementation for a <a href="https://depth-first.com/articles/2021/09/22/beyond-smiles/" target="_blank">molecular language</a> I&rsquo;m working on. If you use Lyn in a project I&rsquo;d be very interested in <a href="/about/">hearing from you</a>.</p>


<h1 class="relative group">About Parser Generators 
    <div id="about-parser-generators" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#about-parser-generators" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>As an alternative to writing a recursive descent parser, it&rsquo;s also possible to build a parser directly from a grammar using a <em>parser generator</em>. Many sources give the impression that a parser generator is the only way to parse. Having used a few parser generators, I don&rsquo;t necessarily agree. Some of the downsides of a parser generator include:</p>
<ul>
<li>Awkward code management. A parser generation will often emit source code that must somehow be integrated within a source tree. But being auto-generated, this code can&rsquo;t be managed with any of the usual workflows.</li>
<li>Confusing stack traces. The flow through auto-generated code can be confusing to follow. This makes debugging more difficult than it otherwise might be.</li>
<li>Some parser generators require learning unfamiliar and/or poorly-supported APIs. These are furthermore sometimes specific to a single programming language. So the investment made in them can&rsquo;t necessarily move on when you do.</li>
</ul>
<p>Although parser generators can save effort in the short term, the full extent of the disadvantages often won&rsquo;t become known until some time in the future of a project. For this reason, I recommend trying to write a recursive descent parser or two first, and only then moving on to a parser generator when the advantages of doing so will clearly outweigh the disadvantages.</p>


<h1 class="relative group">Conclusion 
    <div id="conclusion" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#conclusion" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p>Recursive descent parsers are straightforward to write given a solid starting point. This article has to painted a picture of what this starting point might look like. Two tools are required: a grammar; and a method for turning its production rules into functions. A scanner is a powerful tool for the latter, allowing the resulting functions of a parser to closely resemble the corresponding production rule. A scanner can be as simple or complex as your language requires. Three examples demonstrated how to move repetitive, bug-prone code into the scanner for cleaner, simpler parsers. The <a href="https://crates.io/crates/lyn" target="_blank">Lyn crate</a> offers a fully-functional scanner.</p>


<h1 class="relative group">Acknowledgement 
    <div id="acknowledgement" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#acknowledgement" aria-label="Anchor">#</a>
    </span>        
    
</h1>
<p><a href="https://petermalmgren.com/" target="_blank">Peter Malmgren&rsquo;s</a> article <a href="https://petermalmgren.com/three-rust-parsers/" target="_blank"><em>Implementing a calculator parser in Rust</em></a> helped crystallize some of my ideas about explaining recursive descent parsers.</p>

          
          
          
        </div>
        
        

        
        

          
      </div>
     
      
      
        
        
          
          
        
      <script>
        var oid = "views_posts\/2021-12-16-a-beginners-guide-to-parsing-in-rust.md"
        var oid_likes = "likes_posts\/2021-12-16-a-beginners-guide-to-parsing-in-rust.md"
      </script>
      
      
      <script type="text/javascript" src="/js/page.min.0860cf4e04fa2d72cc33ddba263083464d48f67de06114529043cb4623319efed4f484fd7f1730df5abea0e2da6f3538855634081d02f2d6e920b956f063e823.js" integrity="sha512-CGDPTgT6LXLMM926JjCDRk1I9n3gYRRSkEPLRiMxnv7U9IT9fxcw31q&#43;oOLabzU4hVY0CB0C8tbpILlW8GPoIw=="></script>
      
  
    </section>
  <footer class="pt-8 max-w-prose print:hidden">

    
  
    
    
    
    <div class="pt-8">
      <hr class="border-dotted border-neutral-300 dark:border-neutral-600" />
      <div class="flex justify-between pt-3">
        <span>
          
            <a class="flex group mr-3" href="/articles/2021/12/01/mdl-valence-mageddon/">
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >MDL Valence-Mageddon</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2021-12-01T23:45:00&#43;00:00">December 1, 2021</time>
                  
                </span>
              </span>
            </a>
          
        </span>
        <span>
          
            <a class="flex text-right group ml-3" href="/articles/2021/12/29/stereochemistry-and-the-v2000-molfile-format/">
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >Stereochemistry and the V2000 Molfile Format</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2021-12-29T20:00:00&#43;00:00">December 29, 2021</time>
                  
                </span>
              </span>
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
            </a>
          
        </span>
      </div>
    </div>
  


    
  </footer>
</article>

      <div id="top-scroller" class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0">
  <a href="#the-top"
    class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400"
    aria-label="Scroll to top" title="Scroll to top">
    &uarr;
  </a>
</div>
    </main><footer id="site-footer" class="py-10 print:hidden">
  
  
    
  
  <div class="flex items-center justify-between">

    
    
    <p class="text-sm text-neutral-500 dark:text-neutral-400">
      &copy;
      2024
      
    </p>
    

    
    
    <p class="text-xs text-neutral-500 dark:text-neutral-400">
      
      
      Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> &amp; <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://blowfish.page/" target="_blank" rel="noopener noreferrer">Blowfish</a>
    </p>
    

  </div>
  <script>
    
    mediumZoom(document.querySelectorAll("img:not(.nozoom)"), {
      margin: 24,
      background: 'rgba(0,0,0,0.5)',
      scrollOffset: 0,
    })
    
  </script>
  
  
  <script type="text/javascript" src="/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js" integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh&#43;sCQ0E53ghYrxgYqw&#43;0GCRyIEpA=="></script>
  
  
</footer>
<div
  id="search-wrapper"
  class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]"
  data-url="http://localhost:1313/"
  style="z-index:500"
>
  <div
    id="search-modal"
    class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"
  >
    <header class="relative z-10 flex items-center justify-between flex-none px-2">
      <form class="flex items-center flex-auto min-w-0">
        <div class="flex items-center justify-center w-8 h-8 text-neutral-400">
          

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


        </div>
        <input
          type="search"
          id="search-query"
          class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent"
          placeholder="Search"
          tabindex="0"
        />
      </form>
      <button
        id="close-search-button"
        class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        title="Close (Esc)"
      >
        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>


      </button>
    </header>
    <section class="flex-auto px-2 overflow-auto">
      <ul id="search-results">
        
      </ul>
    </section>
  </div>
</div>

  </div>
</body>

</html>
