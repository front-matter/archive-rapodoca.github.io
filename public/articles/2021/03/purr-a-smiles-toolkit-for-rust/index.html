<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Purr: A SMILES Toolkit for Rust | Depth-First</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Pulling back the covers on a new way to work with SMILES.">
    <meta name="generator" content="Hugo 0.139.4">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/articles/2021/03/purr-a-smiles-toolkit-for-rust/">
    

    <meta property="og:url" content="http://localhost:1313/articles/2021/03/purr-a-smiles-toolkit-for-rust/">
  <meta property="og:site_name" content="Depth-First">
  <meta property="og:title" content="Purr: A SMILES Toolkit for Rust">
  <meta property="og:description" content="Pulling back the covers on a new way to work with SMILES.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2021-03-03T17:00:00+00:00">
    <meta property="article:modified_time" content="2021-03-03T17:00:00+00:00">

  <meta itemprop="name" content="Purr: A SMILES Toolkit for Rust">
  <meta itemprop="description" content="Pulling back the covers on a new way to work with SMILES.">
  <meta itemprop="datePublished" content="2021-03-03T17:00:00+00:00">
  <meta itemprop="dateModified" content="2021-03-03T17:00:00+00:00">
  <meta itemprop="wordCount" content="2370">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Purr: A SMILES Toolkit for Rust">
  <meta name="twitter:description" content="Pulling back the covers on a new way to work with SMILES.">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Depth-First
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Articles
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Purr: A SMILES Toolkit for Rust</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2021-03-03T17:00:00Z">March 3, 2021</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Simplified Molecular Input Line Entry System (SMILES) is the de facto standard for compact molecular representation in cheminformatics. Due to this role, users have come to expect SMILES support in the software packages they use. Developers have responded to the demand with a wide range of products capable of reading and writing SMILES. These products form a broad network of tools that can in principle work together through a common language.</p>
<p>Last year, <a href="/articles/2020/01/20/cheminformatics-in-rust/">I speculated</a> that Rust could play an important role in the future of cheminformatics. SMILES support is an important part of that vision, especially in the short term. Users needing functionality not present in a new platform can get it from older platforms, with SMILES serving as a serialization format.</p>
<p>Lack of functionality is both the biggest weakness and greatest strength of a new platform. There may be few features, but there is also no legacy code to maintain. Users of a new platform tend to be more tolerant of breaking changes, making iterations less disruptive. To the extent that SMILES still has something new to uncover, it&rsquo;s likely to emerge from new cheminformatics platforms.</p>
<p>With these ideas in mind, this article introduces Purr, a suite of tools for reading, writing, and manipulating SMILES in Rust.</p>
<h1 id="quickstart">Quickstart</h1>
<p>After <a href="https://www.rust-lang.org/tools/install">installed the Rust toolchain</a>, create a new project.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cargo new hello_purr <span style="color:#f92672">&amp;&amp;</span> cd hello_purr
</span></span></code></pre></div><p>Next, edit <code>Cargo.toml</code> to look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>[<span style="color:#a6e22e">package</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;hello_purr&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0.1.0&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">authors</span> = [<span style="color:#e6db74">&#34;me &lt;me@example.com&gt;&#34;</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">edition</span> = <span style="color:#e6db74">&#34;2018&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">dependencies</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">purr</span> = <span style="color:#e6db74">&#34;0.9.0&#34;</span>
</span></span></code></pre></div><p>The template project contains the file <code>src/main.rs</code>. All of the examples in this article should be written into it.</p>
<p>Let&rsquo;s start with an example of parsing methanol (<code>CO</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">//src/main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> purr::graph::{ Builder, Atom, Bond };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::feature::{ AtomKind, BondKind, Aliphatic };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::read::{ read, Error };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> builder <span style="color:#f92672">=</span> Builder::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    read(<span style="color:#e6db74">&#34;CO&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> builder, None)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(builder.build(), Ok(vec![
</span></span><span style="display:flex;"><span>        Atom {
</span></span><span style="display:flex;"><span>            kind: <span style="color:#a6e22e">AtomKind</span>::Aliphatic(Aliphatic::C),
</span></span><span style="display:flex;"><span>            bonds: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[
</span></span><span style="display:flex;"><span>                Bond::new(BondKind::Elided, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            ]
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        Atom {
</span></span><span style="display:flex;"><span>            kind: <span style="color:#a6e22e">AtomKind</span>::Aliphatic(Aliphatic::O),
</span></span><span style="display:flex;"><span>            bonds: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[
</span></span><span style="display:flex;"><span>                Bond::new(BondKind::Elided, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            ]
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    ]));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Run the program with <code>cargo run</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>$ cargo run
</span></span><span style="display:flex;"><span>   Compiling purr v0.9.0
</span></span><span style="display:flex;"><span>   Compiling hello_purr v0.1.0 (/Users/rich/tmp/hello_purr)
</span></span><span style="display:flex;"><span>    Finished dev [unoptimized + debuginfo] target(s) in 2.88s
</span></span><span style="display:flex;"><span>     Running `target/debug/hello_purr`
</span></span></code></pre></div><p>The <code>read</code> function transforms a SMILES string into instructions for a <code>Builder</code> argument. <code>Builder</code> transforms the method calls it receives into a representation that can be obtained through its <code>build</code> method. There will be more to say about the methods <code>Builder</code> implements later. For now, the important idea is that <code>read</code> can generate many different output types. The decision of which one will be produced occurs at runtime.</p>
<p><code>Builder</code> returns a vector of atoms (<code>Vec&lt;Atom&gt;</code>) from its <code>build</code> method. As we&rsquo;ll see later, <code>Atom</code> supports data access and methods useful for assigning chemical meaning to the SMILES that was parsed.</p>
<p>To allow errors to be intercepted, <code>read</code> and the <code>build</code> method of <code>Builder</code> return <code>Result</code> types. <code>read</code> also supports an optional parameter that can be used to relate molecular features to cursors within the original SMILES string.</p>
<h1 id="overview">Overview</h1>
<p>Like all SMILES implementations, Purr speaks a dialect of SMILES. Purr&rsquo;s dialect is based on the one presented in the <a href="http://opensmiles.org/opensmiles.html">OpenSMILES</a> specification. Although OpenSMILES is the most detailed SMILES specification to date, it has limitations. In cases of contradictory or incomplete OpenSMILES guidance, Purr draws from other sources in roughly this order: Daylight&rsquo;s online documentation; peer-reviewed publications; books; blog posts; mailing list discussions; and personal communications. In rare cases, Purr has introduced some new rules.</p>
<p>By default and by design, Purr enforces only syntax when reading or writing SMILES. The syntax of strings is checked by a hand-crafted <a href="/articles/2019/01/22/scanner-driven-parser-development/">recursive descent parser</a>. The parser is itself based on a <a href="/articles/2020/12/21/smiles-formal-grammar-revisited/">formal grammar</a> that has undergone several revisions over the years. But sematic errors such as <a href="/articles/2020/03/16/formal-charge-and-bond-order-are-side-effects/">negative implied valence electron count</a>, negative implied neutron count, and mismatched or unbalanced ring closure bonds are not checked by default. Purr does offer the tools needed to perform such checks if desired.</p>
<p>This pay-as-you-go approach is seen throughout Purr. If you don&rsquo;t need a service, you shouldn&rsquo;t have to pay for it — either with performance or complexity.</p>
<p>The cornerstone of Purr&rsquo;s design is the <code>Follower</code> trait. <code>Follower</code> defines four methods relating SMILES features to actions: <code>root</code>; <code>extend</code>; <code>join</code>; and <code>pop</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::feature::{ AtomKind, BondKind, Rnum };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// The actions possible during a depth-first traversal of a SMILES
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// representation.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Follower {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// A root atom has been found. This occurs at the first atom of every
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// connected component. As such, every use of `Follower` must
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// begin with at least one call to `root`. But `root` can also be called
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// after the first atom has been found, as in methane hydrate (`C.O`).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">root</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, root: <span style="color:#a6e22e">AtomKind</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// A bond between the current head atom and the next head atom has
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// been found. Using this method implies the existence of a head atom,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// as in methanol (`C-O` or `CO`).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// # Panics
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// Panics if headless.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">extend</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, bond_kind: <span style="color:#a6e22e">BondKind</span>, atom_kind: <span style="color:#a6e22e">AtomKind</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// A bond between the current head atom and a ring closure digit has
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// been found. Using this method implies the existence of a head atom,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// as in cyclopropane (`C1CC1`).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// # Panics
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// Panics if headless.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">join</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, bond_kind: <span style="color:#a6e22e">BondKind</span>, rnum: <span style="color:#a6e22e">Rnum</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Pop the stack by the indicated depth. As roots and extensions are
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// encountered, `Follower` builds a working path. Branching removes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// one or more atoms from the head of this path, exposing a new head.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// The newly-exposed head will have previously been a head.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// # Panics
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// Panics given depth exceeds the length of the current path.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">pop</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, depth: <span style="color:#66d9ef">usize</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Think of <code>Follower</code> as a companion that tags along during the depth-first traversal of a SMILES representation. For example, we can simulate a traversal that would represent acetamide (<code>CC(=O)N</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::walk::Follower;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::feature::{ AtomKind, BondKind, Aliphatic };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// CC(=O)N
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">acetamide</span><span style="color:#f92672">&lt;</span>F: <span style="color:#a6e22e">Follower</span><span style="color:#f92672">&gt;</span>(follower: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> F) {
</span></span><span style="display:flex;"><span>    follower.root(AtomKind::Aliphatic(Aliphatic::C));
</span></span><span style="display:flex;"><span>    follower.extend(BondKind::Elided, AtomKind::Aliphatic(Aliphatic::C));
</span></span><span style="display:flex;"><span>    follower.extend(BondKind::Double, AtomKind::Aliphatic(Aliphatic::O));
</span></span><span style="display:flex;"><span>    follower.pop(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    follower.extend(BondKind::Elided, AtomKind::Aliphatic(Aliphatic::N));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Follower</code> decouples the traversal of a SMILES representation from the use of the features that are discovered along the way. This means that the same traversal function can yield a variety of different products, and these products can be chosen at runtime. This is how Purr makes good on its pay-as-you-go promise. An example of the flexibility of this approach can be seen when reading SMILES strings.</p>
<h1 id="reading-smiles">Reading SMILES</h1>
<p>The <code>read</code> function accepts a SMILES string representation and a value of type <code>Follower</code>. After the function returns, the product built by the <code>Follower</code> can be used. For example, we can count the number of atomic nodes (explicit atoms) in a SMILES string as like so.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> purr::walk::Follower;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::feature::{ AtomKind, BondKind, Rnum };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::read::{ read, Error };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Counter</span> {
</span></span><span style="display:flex;"><span>    count: <span style="color:#66d9ef">usize</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Follower <span style="color:#66d9ef">for</span> Counter {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">root</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, _: <span style="color:#a6e22e">AtomKind</span>) {
</span></span><span style="display:flex;"><span>      self.count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">extend</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, _: <span style="color:#a6e22e">BondKind</span>, _: <span style="color:#a6e22e">AtomKind</span>) {
</span></span><span style="display:flex;"><span>        self.count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">join</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, _: <span style="color:#a6e22e">BondKind</span>, _: <span style="color:#a6e22e">Rnum</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// no-op
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">pop</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, _: <span style="color:#66d9ef">usize</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// no-op
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> counter <span style="color:#f92672">=</span> Counter { count: <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    read(<span style="color:#e6db74">&#34;c1cc([O-]ccc1&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> counter, None)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(counter.count, <span style="color:#ae81ff">7</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice that not all <code>Follower</code> methods need to be implemented, nor do they need to be implemented in any particular way. This makes it possible to create highly efficient SMILES analyses targeted to specific applications.</p>
<p>Purr provides two important <code>Follower</code> implementations out of the box:</p>
<ul>
<li><code>Writer</code>. Yields a string representation.</li>
<li><code>Builder</code>. Yields an adjacency list implementation.</li>
</ul>
<p>Because both <code>Writer</code> and <code>Builder</code> implement <code>Follower</code>, they can be used interchangeably in any situation calling for a <code>Follower</code>. For example, a SMILES string can be &ldquo;round tripped&rdquo; by combining <code>read</code> with <code>Writer</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> purr::read::{ read, Error };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::write::Writer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> Writer::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    read(<span style="color:#e6db74">&#34;[C@H](F)(Cl)Br&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> writer, None)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(writer.write(), <span style="color:#e6db74">&#34;[C@H](F)(Cl)Br&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Likewise, combining <code>read</code> with <code>Builder</code> yields an adjacency list representation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> purr::feature::{
</span></span><span style="display:flex;"><span>    AtomKind, BondKind, Element, VirtualHydrogen, Configuration,
</span></span><span style="display:flex;"><span>    Aliphatic, BracketSymbol
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::read::{ read, Error };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::graph::{ Builder, Atom, Bond };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> builder <span style="color:#f92672">=</span> Builder::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    read(<span style="color:#e6db74">&#34;[C@H](F)(Cl)Br&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> builder, None)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(builder.build(), Ok(vec![
</span></span><span style="display:flex;"><span>        Atom {
</span></span><span style="display:flex;"><span>            kind: <span style="color:#a6e22e">AtomKind</span>::Bracket {
</span></span><span style="display:flex;"><span>                isotope: None,
</span></span><span style="display:flex;"><span>                symbol: <span style="color:#a6e22e">BracketSymbol</span>::Element(Element::C),
</span></span><span style="display:flex;"><span>                configuration: Some(Configuration::<span style="color:#66d9ef">TH1</span>),
</span></span><span style="display:flex;"><span>                hcount: Some(VirtualHydrogen::H1),
</span></span><span style="display:flex;"><span>                charge: None,
</span></span><span style="display:flex;"><span>                map: None
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            bonds: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[
</span></span><span style="display:flex;"><span>                Bond::new(BondKind::Elided, <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>                Bond::new(BondKind::Elided, <span style="color:#ae81ff">2</span>),
</span></span><span style="display:flex;"><span>                Bond::new(BondKind::Elided, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>            ]
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        Atom {
</span></span><span style="display:flex;"><span>          kind: <span style="color:#a6e22e">AtomKind</span>::Aliphatic(Aliphatic::F),
</span></span><span style="display:flex;"><span>          bonds: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[
</span></span><span style="display:flex;"><span>              Bond::new(BondKind::Elided, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>          ]
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        Atom {
</span></span><span style="display:flex;"><span>            kind: <span style="color:#a6e22e">AtomKind</span>::Aliphatic(Aliphatic::Cl),
</span></span><span style="display:flex;"><span>            bonds: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[
</span></span><span style="display:flex;"><span>                Bond::new(BondKind::Elided, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            ]
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        Atom {
</span></span><span style="display:flex;"><span>            kind: <span style="color:#a6e22e">AtomKind</span>::Aliphatic(Aliphatic::Br),
</span></span><span style="display:flex;"><span>            bonds: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[
</span></span><span style="display:flex;"><span>                Bond::new(BondKind::Elided, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            ]
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    ]));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Syntax errors detected by <code>read</code> come in one of two variants: <code>read::Error::Character</code> and <code>read::Error::EndOfLine</code>. The former is parameterized with a cursor position (as type <code>usize</code>), allowing the precise location of errors to be flagged for users.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> purr::graph::Builder;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::read::{ read, Error };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> builder1 <span style="color:#f92672">=</span> Builder::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> builder2 <span style="color:#f92672">=</span> Builder::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(read(<span style="color:#e6db74">&#34;CC?C&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> builder1, None), Err(Error::Character(<span style="color:#ae81ff">2</span>)));
</span></span><span style="display:flex;"><span>    assert_eq!(read(<span style="color:#e6db74">&#34;CCC[CH2&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> builder2, None), Err(Error::EndOfLine))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>read</code> also supports fine-grained semantic error reporting and feature linking with an optional <code>Trace</code> argument. The purpose of <code>Trace</code> is to associate SMILES features with cursor positions in the original string. Because it&rsquo;s optional, clients that don&rsquo;t need the functionality of <code>Trace</code> also don&rsquo;t need to pay for it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> purr::read::{ read, Error, Trace };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::graph::Builder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> builder <span style="color:#f92672">=</span> Builder::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> trace <span style="color:#f92672">=</span> Trace::new();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//    012345678901234567890123 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    read(<span style="color:#e6db74">&#34;C[NH-]c1ccccc1C/C=C(/C)</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">C&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> builder, Some(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> trace))<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(trace.atom(<span style="color:#ae81ff">1</span>), Some(<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">6</span>));  <span style="color:#75715e">// [NH-]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    assert_eq!(trace.bond(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>), Some(<span style="color:#ae81ff">1</span>));  <span style="color:#75715e">// elided bond between C and [HN-]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    assert_eq!(trace.bond(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>), Some(<span style="color:#ae81ff">15</span>)); <span style="color:#75715e">// first up (/) bond
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="writing-smiles">Writing SMILES</h1>
<p>Adjacency representations can be obtained in one of three ways:</p>
<ol>
<li>from a <code>Builder</code> using <code>read</code>, as shown in the previous section;</li>
<li>from a <code>Builder</code> using ad hoc method calls; and</li>
<li>by assembling <code>Atom</code>s and <code>Bond</code>s manually.</li>
</ol>
<p>It&rsquo;s often useful to write an adjacency representation as a SMILES string. To do so, combine <code>Writer</code> with the <code>walk</code> function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> purr::graph::Builder;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::walk::{ walk, Follower, Error };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::feature::AtomKind;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::write::Writer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> builder <span style="color:#f92672">=</span> Builder::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    builder.root(AtomKind::Star);
</span></span><span style="display:flex;"><span>    builder.root(AtomKind::Star);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> adjacency <span style="color:#f92672">=</span> builder.build().expect(<span style="color:#e6db74">&#34;adjacency&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> writer <span style="color:#f92672">=</span> Writer::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    walk(adjacency, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> writer)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(writer.write(), <span style="color:#e6db74">&#34;*.*&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Both <code>read</code> and <code>walk</code> accept a parameter of type <code>Follower</code>. This blurs the distinction between reading and writing a SMILES representation. Both processes are just transformations. For example, the <code>Counter</code> type from the previous section can be combined with <code>walk</code>. When <code>read</code> and <code>walk</code> are paired with the same <code>Follower</code>, string and adjacency SMILES representations become functionally equivalent.</p>
<h1 id="using-smiles">Using SMILES</h1>
<p>It&rsquo;s often important to do more than just read and write SMILES representations. Purr supports sophisticated analyses through the <code>Atom</code> and <code>Bond</code> types.</p>
<p><code>Atom</code> provides methods to query valence and bonding relationships. For example, <a href="/articles/2021/02/10/fast-hydrogen-counting-hydrogens-in-smiles/">suppressed hydrogen count</a> can be computed as follows.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> purr::feature::{ AtomKind, BondKind, Aliphatic };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::graph::{ Atom, Bond };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> atom <span style="color:#f92672">=</span> Atom {
</span></span><span style="display:flex;"><span>        kind: <span style="color:#a6e22e">AtomKind</span>::Aliphatic(Aliphatic::C),
</span></span><span style="display:flex;"><span>        bonds: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[
</span></span><span style="display:flex;"><span>            Bond::new(BondKind::Elided, <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>            Bond::new(BondKind::Double, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>        ]
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(atom.suppressed_hydrogens(), <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>subvalence</code> method of <code>Atom</code> makes it possible to prune a π-subgraph, a prerequisite for <a href="/articles/2020/02/10/a-comprehensive-treatment-of-aromaticity-in-the-smiles-language/">kekulization</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> purr::feature::{ AtomKind, BondKind, Aromatic };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::graph::{ Atom, Bond };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> oxygen <span style="color:#f92672">=</span> Atom {
</span></span><span style="display:flex;"><span>        kind: <span style="color:#a6e22e">AtomKind</span>::Aromatic(Aromatic::O),
</span></span><span style="display:flex;"><span>        bonds: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[
</span></span><span style="display:flex;"><span>            Bond::new(BondKind::Elided, <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>            Bond::new(BondKind::Elided, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>        ]
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> carbon <span style="color:#f92672">=</span> Atom {
</span></span><span style="display:flex;"><span>        kind: <span style="color:#a6e22e">AtomKind</span>::Aromatic(Aromatic::C),
</span></span><span style="display:flex;"><span>        bonds: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[
</span></span><span style="display:flex;"><span>            Bond::new(BondKind::Elided, <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>            Bond::new(BondKind::Elided, <span style="color:#ae81ff">2</span>),
</span></span><span style="display:flex;"><span>            Bond::new(BondKind::Elided, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>        ]
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(oxygen.subvalence(), <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// prune from π-subgraph
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    assert_eq!(carbon.subvalence(), <span style="color:#ae81ff">1</span>)  <span style="color:#75715e">// don&#39;t prune
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><code>Bond</code> supports three convenience methods for querying a bond.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> purr::feature::BondKind;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> purr::graph::Bond;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bond <span style="color:#f92672">=</span> Bond::new(BondKind::Double, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(bond.order(), <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    assert_eq!(bond.is_aromatic(), <span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>    assert_eq!(bond.is_directional(), <span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="other-work">Other Work</h1>
<p>Two other Rust crates support working with SMILES to varying degrees:</p>
<ul>
<li><a href="https://github.com/hobofan/smiles-parser">smiles-parser</a>. Based on the <a href="https://github.com/Geal/nom">nom</a> parser combinator.</li>
<li><a href="https://gitlab.com/acetylene/acetylene-parser">acetylene-parser</a>. Appears to be inactive.</li>
</ul>
<p>According to the available documentation, neither project is currently as full-featured as Purr.</p>
<p>In addition to these projects, three other dedicated SMILES libraries have been developed over the years.</p>
<ul>
<li><a href="https://github.com/timvdm/Smiley">Smiley</a>. A SMILES/SMARTS parser written in C++. Smiley has been <a href="https://open-babel.readthedocs.io/en/latest/FileFormats/SMILES_format_using_Smiley_parser.html">integrated</a> into Open Babel.</li>
<li><a href="https://github.com/johnmay/beam">Beam</a>. A Java library &ldquo;dedicated to parsing and generating&rdquo; SMILES. Beam has been integrated into the <a href="https://cdk.github.io">Chemistry Development Kit</a>.</li>
<li><a href="http://frowns.sourceforge.net">Frowns</a>. A Python library written in Python. Frowns has not been active for some time.</li>
</ul>
<h1 id="is-this-necessary">Is This Necessary?</h1>
<p>It may seem like overkill for a library to focus just on reading, writing, and manipulating SMILES. After all, SMILES is a simple language and most toolkits offer the ability to work with SMILES anyway.</p>
<p>Not so fast. First, as several articles here and elsewhere have demonstrated, SMILES <em>syntax</em> may be simple, but its <em>semantics</em> are both extremely complex and incompletely documented. Projects like Smiley, Beam, and Purr that deal exclusively with SMILES shine a spotlight on the numerous subtleties present in the language.</p>
<p>Second, Rust&rsquo;s package manager Cargo makes it trivial to assemble software components like Purr into a cohesive whole. Although most modern languages have package managers, the problem is that there are too many of them (Python, I&rsquo;m looking at you). Rust is different. Cargo is both ubiquitous and unique. There is no competition in the Rust package manager space. This feature has already been used to integrate Purr with <a href="/articles/2020/06/01/chemcore-a-cheminformatics-toolkit-for-rust/">ChemCore</a>, a cheminformatics toolkit for Rust.</p>
<p>Third, as I&rsquo;ll highlight on this blog from time to time, you can do a lot in cheminformatics without a toolkit. Purr in particular offers enough functionality that it can be used on its own to solve some problems. It&rsquo;s not inconceivable that a set of crates linking directly to Purr (and bypassing ChemCore) might eventually become available. Purr&rsquo;s avoidance of build dependencies makes it a good candidate for projects trying to avoid bloat.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Purr is a new Rust toolkit that supports reading, writing, and manipulating SMILES. All OpenSMILES language features are supported. Although the most likely path is for Purr to be integrated into a cheminformatics toolkit, it can also be used by itself as a zero-dependency dependency. As such, the design and implementation of Purr may offer useful pointers to what a new cheminformatics platform built on Rust might look like.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Depth-First 2024 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
