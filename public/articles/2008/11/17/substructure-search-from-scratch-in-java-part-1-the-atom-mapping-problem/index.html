<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Substructure Search From Scratch in Java Part 1 - The Atom Mapping Problem | Depth-First</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="One of the most important capabilities in cheminformatics is mapping the atoms of a query structure onto the atoms of a target structure. Although useful in itself, the main value of atom mapping comes from the software that gets built on top of it: exact structure comparators, substructure search systems, and query atom/bond search systems such as SMARTS. The fundamental nature of atom mapping means that correctness, efficiency and adaptability are essential features of a good mapping implementation. Recently, a D-F article made the case that atom mapping software written in Java needs to be Java-centric to achieve these goals. This article, the first in a series that describes a complete substructure search system written in Java, takes the first step by offering some simple interface definitions and code for the atom mapping problem.">
    <meta name="generator" content="Hugo 0.139.4">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/articles/2008/11/17/substructure-search-from-scratch-in-java-part-1-the-atom-mapping-problem/">
    

    <meta property="og:url" content="http://localhost:1313/articles/2008/11/17/substructure-search-from-scratch-in-java-part-1-the-atom-mapping-problem/">
  <meta property="og:site_name" content="Depth-First">
  <meta property="og:title" content="Substructure Search From Scratch in Java Part 1 - The Atom Mapping Problem">
  <meta property="og:description" content="One of the most important capabilities in cheminformatics is mapping the atoms of a query structure onto the atoms of a target structure. Although useful in itself, the main value of atom mapping comes from the software that gets built on top of it: exact structure comparators, substructure search systems, and query atom/bond search systems such as SMARTS. The fundamental nature of atom mapping means that correctness, efficiency and adaptability are essential features of a good mapping implementation. Recently, a D-F article made the case that atom mapping software written in Java needs to be Java-centric to achieve these goals. This article, the first in a series that describes a complete substructure search system written in Java, takes the first step by offering some simple interface definitions and code for the atom mapping problem.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2008-11-17T00:00:00+00:00">
    <meta property="article:modified_time" content="2008-11-17T00:00:00+00:00">

  <meta itemprop="name" content="Substructure Search From Scratch in Java Part 1 - The Atom Mapping Problem">
  <meta itemprop="description" content="One of the most important capabilities in cheminformatics is mapping the atoms of a query structure onto the atoms of a target structure. Although useful in itself, the main value of atom mapping comes from the software that gets built on top of it: exact structure comparators, substructure search systems, and query atom/bond search systems such as SMARTS. The fundamental nature of atom mapping means that correctness, efficiency and adaptability are essential features of a good mapping implementation. Recently, a D-F article made the case that atom mapping software written in Java needs to be Java-centric to achieve these goals. This article, the first in a series that describes a complete substructure search system written in Java, takes the first step by offering some simple interface definitions and code for the atom mapping problem.">
  <meta itemprop="datePublished" content="2008-11-17T00:00:00+00:00">
  <meta itemprop="dateModified" content="2008-11-17T00:00:00+00:00">
  <meta itemprop="wordCount" content="783">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Substructure Search From Scratch in Java Part 1 - The Atom Mapping Problem">
  <meta name="twitter:description" content="One of the most important capabilities in cheminformatics is mapping the atoms of a query structure onto the atoms of a target structure. Although useful in itself, the main value of atom mapping comes from the software that gets built on top of it: exact structure comparators, substructure search systems, and query atom/bond search systems such as SMARTS. The fundamental nature of atom mapping means that correctness, efficiency and adaptability are essential features of a good mapping implementation. Recently, a D-F article made the case that atom mapping software written in Java needs to be Java-centric to achieve these goals. This article, the first in a series that describes a complete substructure search system written in Java, takes the first step by offering some simple interface definitions and code for the atom mapping problem.">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Depth-First
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Articles
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Substructure Search From Scratch in Java Part 1 - The Atom Mapping Problem</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2008-11-17T00:00:00Z">November 17, 2008</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>One of the most important capabilities in cheminformatics is mapping the atoms of a <em>query structure</em> onto the atoms of a <em>target structure</em>. Although useful in itself, the main value of atom mapping comes from the software that gets built on top of it: exact structure comparators, <a href="/articles/2008/10/02/fast-substructure-search-using-open-source-tools-part-1-fingerprints-and-databases">substructure search systems</a>, and query atom/bond search systems such as <a href="http://www.daylight.com/dayhtml/doc/theory/theory.smarts.html">SMARTS</a>. The fundamental nature of atom mapping means that correctness, efficiency and adaptability are essential features of a good mapping implementation. Recently, a D-F article made the case that atom mapping software written in Java <a href="/articles/2008/11/13/one-of-these-things-is-not-like-the-other">needs to be Java-centric</a> to achieve these goals. This article, the first in a series that describes a complete substructure search system written in Java, takes the first step by offering some simple interface definitions and code for the atom mapping problem.</p>
<h1 id="the-problem">The Problem</h1>
<p>Given a query molecule (<code>query</code>) and a target molecule (<code>target</code>), our atom mapping software needs to find ways to match the atoms of <code>query</code> onto <code>target</code> such that the mapping describes a substructure embedded in <code>target</code>. The software might stop at one mapping, continue on to find all of them, or stop at some point in the middle. It all depends on the specific cheminformatics problem we&rsquo;re trying to solve.</p>
<h1 id="the-recursive-function">The Recursive Function</h1>
<p>Our implementation will gradually build up an atom mapping by traversing the atoms of <code>query</code> in depth-first order and trying to map each found atom onto an atom in <code>target</code>. At each step in the process, we will have a partial atom map that maps some of the atoms in <code>query</code> onto <code>target</code>. That map, and any other information needed to complete the analysis will be kept in an instance of a class implementing the <code>State</code> interface.</p>
<p>A <code>State</code> will be manipulated by a recursive method, <code>mapFirst</code> that returns when the first atom map is found:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// create a list to hold atom maps</span>
</span></span><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">&lt;</span>Atom, Atom<span style="color:#f92672">&gt;&gt;</span> maps <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">&lt;</span>Atom, Atom<span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// create initial state</span>
</span></span><span style="display:flex;"><span>State state <span style="color:#f92672">=</span> ...; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">mapFirst</span>(State state)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (state.<span style="color:#a6e22e">isDead</span>())
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (state.<span style="color:#a6e22e">isGoal</span>())
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    maps.<span style="color:#a6e22e">add</span>(state.<span style="color:#a6e22e">getMap</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">boolean</span> found <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>found <span style="color:#f92672">&amp;&amp;</span> state.<span style="color:#a6e22e">hasNextCandidate</span>())
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    Match candidate <span style="color:#f92672">=</span> state.<span style="color:#a6e22e">nextCandidate</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (state.<span style="color:#a6e22e">isMatchFeasible</span>(candidate))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      State nextState <span style="color:#f92672">=</span> state.<span style="color:#a6e22e">nextState</span>(candidate);
</span></span><span style="display:flex;"><span>      found <span style="color:#f92672">=</span> mapFirst(nextState);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      nextState.<span style="color:#a6e22e">backTrack</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> found;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Comparison of the <code>mapFirst</code> method to the pseudocode <a href="/articles/2008/11/13/one-of-these-things-is-not-like-the-other">VF algorithm <code>Match</code> procedure given in the previous article</a> shows some similarities. In fact, something similar to the <code>mapFirst</code> method forms the basis of many atom mappers in use today.</p>
<p>Although it may be clear from the code, it&rsquo;s worth re-iterating that each time <code>mapFirst</code> is recursively called, an attempt is made to branch off a new <code>State</code> that maps an additional pair of atoms from <code>query</code> to <code>target</code>. If that branch leads to a possible solution, it&rsquo;s followed. Otherwise the next possible mapping is explored.</p>
<h1 id="the-state-interface">The <code>State</code> Interface</h1>
<p>The recursive <code>mapFirst</code> method determines all of the methods the <code>State</code> interface needs to define:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">State</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * Returns the current mapping of query atoms onto target atoms.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * This map is shared among all states obtained through nextState.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> Map<span style="color:#f92672">&amp;</span>lt;Atom, Atom<span style="color:#f92672">&amp;</span>gt; getMap();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * Returns true if another candidate match can be found or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * false otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hasNextCandidate</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * Returns the next candidate match.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> Match <span style="color:#a6e22e">nextCandidate</span>();
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * Returns true if the given match will work with the current
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * map, or false otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isMatchFeasible</span>(Match match);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * Returns true if all atoms in the query molecule have been
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * mapped.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isGoal</span>();
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * Returns true if no match will come from this State.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isDead</span>();
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * Returns a state in which the atoms in match have been
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * added to the current mapping.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> State <span style="color:#a6e22e">nextState</span>(Match match);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * Returns this State&#39;s atom map to its original condition.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backTrack</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally, <code>State</code> uses an instance of the <code>Match</code> class:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Match</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> Atom query;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> Atom target;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Match</span>(Atom query, Atom target)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">query</span> <span style="color:#f92672">=</span> query;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">target</span> <span style="color:#f92672">=</span> target;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> Atom <span style="color:#a6e22e">getQueryAtom</span>()
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> query;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> Atom <span style="color:#a6e22e">getTargetAtom</span>()
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> target;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="conclusions">Conclusions</h1>
<p>With just a few lines of Java, we&rsquo;ve managed to reduce the fundamental cheminformatics problem of atom mapping to the far simpler problem of implementing the <code>State</code> interface.</p>
<p>How many ways are there to implement the <code>State</code> interface? Probably as many as there are subgraph isomorphism algorithms. Notice that the way we&rsquo;ve set up the problem lets us use the same recursive method to test all <code>State</code> implementations, an essential prerequisite for benchmarking and optimization.</p>
<p>Future articles in this series will describe one way to implement the <code>State</code> interface.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Depth-First 2024 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
