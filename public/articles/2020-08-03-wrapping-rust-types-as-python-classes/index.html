<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Wrapping Rust Types as Python Classes | Depth-First</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="A step-by-step guide to rolling your own pythonic Rust wrappers.">
    <meta name="generator" content="Hugo 0.139.4">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/articles/2020-08-03-wrapping-rust-types-as-python-classes/">
    

    <meta property="og:url" content="http://localhost:1313/articles/2020-08-03-wrapping-rust-types-as-python-classes/">
  <meta property="og:site_name" content="Depth-First">
  <meta property="og:title" content="Wrapping Rust Types as Python Classes">
  <meta property="og:description" content="A step-by-step guide to rolling your own pythonic Rust wrappers.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2020-08-03T19:00:00+00:00">
    <meta property="article:modified_time" content="2020-08-03T19:00:00+00:00">

  <meta itemprop="name" content="Wrapping Rust Types as Python Classes">
  <meta itemprop="description" content="A step-by-step guide to rolling your own pythonic Rust wrappers.">
  <meta itemprop="datePublished" content="2020-08-03T19:00:00+00:00">
  <meta itemprop="dateModified" content="2020-08-03T19:00:00+00:00">
  <meta itemprop="wordCount" content="1895">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Wrapping Rust Types as Python Classes">
  <meta name="twitter:description" content="A step-by-step guide to rolling your own pythonic Rust wrappers.">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Depth-First
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Articles
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Wrapping Rust Types as Python Classes</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2020-08-03T19:00:00Z">August 3, 2020</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Python has evolved into scientific computing&rsquo;s standard orchestration language. In this role, Python sits at the top of a software stack, directing the actions of components written in low-level languages below. This architecture allows Python to deliver developer productivity while the low-level language delivers performance. This system requires a robust communication channel, which is typically supplied by a &ldquo;Python wrapper.&rdquo;</p>
<p>The <a href="https://blog.rust-lang.org/2015/05/15/Rust-1.0.html">recent</a> maturation of Rust as a stable, full-featured systems programming platform raises the possibility that it could replace C and C++ in some Python orchestration scenarios. My own interest lies in using <a href="/articles/2020/06/01/chemcore-a-cheminformatics-toolkit-for-rust/">a cheminformatics library written in Rust</a> from Python.</p>
<p>A lot has been written about calling Rust code from Python. In researching the topic, however, I found that most documentation begins and ends with simple functions. Python and Rust both support object-oriented programming features, but using them through a wrapper requires non-obvious, lightly-documented refinements. This article fills the gap by showing how to build a Python wrapper for a nontrivial, persistent Rust object.</p>
<h1 id="prerequisites">Prerequisites</h1>
<p>This tutorial assumes that you&rsquo;ve installed a Python 3 interpreter and a <a href="https://rustup.rs">Rust compiler</a>.</p>
<h1 id="overview">Overview</h1>
<p>The project&rsquo;s goal is to wrap a subset of Rust&rsquo;s <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">HashSet</a> type, an unordered collection of unique values. Like most languages, Python <a href="https://docs.python.org/3/tutorial/datastructures.html#sets">already includes this functionality</a>. So the objective isn&rsquo;t practical but rather educational. Using <code>HashMap</code> simplifies the project, allowing it to fucus on the Rust and Python interfaces themselves.</p>
<p>The wrapping technique can be summarized as follows:</p>
<ol>
<li>Write a Rust FFI interface.</li>
<li>Write a Python Ctypes interface</li>
<li>Write a Python API.</li>
<li>Test the Python API.</li>
</ol>
<p>Here&rsquo;s the directory layout for the project:</p>
<!-- raw HTML omitted -->
<p>Several sources proved crucial in my research on this topic, including:</p>
<ul>
<li><a href="http://jakegoulding.com/rust-ffi-omnibus/">The Rust FFI Omnibus</a>. A cookbook illustrating various FFI wrapping scenarios, with support for Ruby, Node, Python, Java, C, C#, Julia, and Haskell.</li>
<li><a href="https://michael-f-bryan.github.io/rust-ffi-guide/">The Unofficial Rust FFI Guide</a>. I found the section on error handling and return types especially helpful.</li>
<li><a href="https://bheisler.github.io/post/calling-rust-in-python/">Calling Rust From Python</a>. A detailed example of Rust object instantiation and control from Python using a somewhat different approach than presented here.</li>
<li><a href="https://stackoverflow.com/questions/26277322/passing-arrays-with-ctypes">passing arrays with ctypes</a>. From StackOverflow.</li>
<li><a href="https://stackoverflow.com/questions/40219711/dereference-ffi-pointer-in-python-to-get-underlying-array">Dereference FFI pointer in Python to get underlying array</a>. From StackOverflow.</li>
</ul>
<p>The full project is fairly small. Even so, you may wish to <a href="https://github.com/rapodaca/hash_set/">download it from GitHub</a>.</p>
<h1 id="create-a-project">Create a Project</h1>
<p>We begin by creating a Rust project in <a href="/articles/2020/07/07/rust-and-webassembly-from-scratch-hello-world-with-strings/">the usual way</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>cargo new hash_set --lib &amp;&amp; cd hash_set
</span></span></code></pre></div><h1 id="rust-ffi-interface">Rust FFI Interface</h1>
<p>The Rust side uses Foreign Function Interface (FFI), a general-purpose mechanism for producing a binary suitable for bindings in not just Python, but other languages. The interface consists of a set of isolated methods that work together to produce an object lifecycle with a constructor, destructor, and methods.</p>
<p>First, we bring in two dependencies: the <code>HashSet</code> type itself (which will be wrapped) and the <code>size_t</code> type from <a href="https://crates.io/crates/libc">libc</a>. The latter allows translation between certain Rust primitive types and their corresponding C constructs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/lib.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> std::collections::HashSet;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> libc::size_t;
</span></span></code></pre></div><p>Next comes a function to construct a <code>HashSet</code> and return it to the caller - ultimately Python. Rust&rsquo;s most unusual (and powerful) feature is compile-time memory management in which values are allocated on the stack by default. We bypass this by moving the <code>HashSet</code> instance to the heap via <a href="https://doc.rust-lang.org/stable/rust-by-example/std/box.html"><code>Box</code></a>, then returning a raw pointer to it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/lib.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#[no_mangle]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">hash_set_new</span>() -&gt; <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> HashSet<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> HashSet::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Box::into_raw(Box::new(result))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A <code>HashMap</code> instance allocated in this way will eventually need to be deallocated. The <code>hash_set_delete</code> function enables memory allocated by Rust to be cleanly reclaimed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/lib.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#[no_mangle]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">hash_set_delete</span>(set: <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> HashSet<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> set.is_null() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        Box::from_raw(set);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span></code></pre></div><p>This function is remarkably straightforward. We first check that the raw pointer is not null. If not, we bring the <code>HashSet</code> instance into scope on the stack. Rust&rsquo;s compile time memory management does the rest, freeing the memory as expected.</p>
<p>With the birth and death of a <code>HashSet</code> defined, we can begin to define its functionality. For this we use a set of functions, each of which follows the same basic pattern:</p>
<ol>
<li>De-reference the pointer to the Rust instance.</li>
<li>Use the Rust instance to obtain a result.</li>
<li>Report the result.</li>
</ol>
<p>Take, for example, the <code>contains</code> method, which returns a boolean indicating whether a value is a member of the <code>HashSet</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/lib.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#[no_mangle]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">hash_set_contains</span>(
</span></span><span style="display:flex;"><span>    set: <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> HashSet<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>, item: <span style="color:#a6e22e">size_t</span>, result: <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>) -&gt; <span style="color:#66d9ef">i8</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> set <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> <span style="color:#66d9ef">unsafe</span> { set.as_ref() } {
</span></span><span style="display:flex;"><span>        Some(set) <span style="color:#f92672">=&gt;</span> set,
</span></span><span style="display:flex;"><span>        None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> <span style="color:#66d9ef">unsafe</span> { result.as_mut() } {
</span></span><span style="display:flex;"><span>        Some(result) <span style="color:#f92672">=&gt;</span> result,
</span></span><span style="display:flex;"><span>        None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std::mem::replace(result, set.contains(<span style="color:#f92672">&amp;</span>item));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span></code></pre></div><p>The first thing that jumps out is that the return type is used to to signal success/error conditions, whereas an input parameter pointer store the actual result. This pattern is common in FFI libraries. The idea is that native wrapper code should never panic on an error condition, but instead report an error as a return value. In the case above, the error condition will be reported as <code>-1</code> and success as <code>0</code>. Although not pursued here, we could take this idea one step further with a <a href="https://s3.amazonaws.com/temp.michaelfbryan.com/errors/index.html">thread-local last error code</a>.</p>
<p>The boolean result is passed as a raw pointer whose value is re-written by a call to <a href="https://doc.rust-lang.org/std/mem/fn.replace.html"><code>std::mem::replace</code></a>. In other words, the Python side will be responsible for managing the memory of the result, eliminating the need for bloating the Rust side with this cleanup. As we&rsquo;ll see below, it turns out that Python is very well-suited to this approach.</p>
<p>Although the remaining functions follow a very similar pattern, one point of interest is the <code>collect</code> method wrapper.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// src/lib.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#[no_mangle]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">hash_set_collect</span>(
</span></span><span style="display:flex;"><span>    set: <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> HashSet<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>, result: <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> size_t
</span></span><span style="display:flex;"><span>) -&gt; <span style="color:#66d9ef">i8</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> set <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> <span style="color:#66d9ef">unsafe</span> { set.as_ref() } {
</span></span><span style="display:flex;"><span>        Some(set) <span style="color:#f92672">=&gt;</span> set,
</span></span><span style="display:flex;"><span>        None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> items <span style="color:#f92672">=</span> set.iter().cloned().collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        std::ptr::copy((<span style="color:#f92672">&amp;</span>items[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>]).as_ptr(), result, items.len());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span></code></pre></div><p>On the Python side, the <code>HashSet::collect</code> method returns the elements of the set as a list. Keeping with the theme that Python will manage its own memory, the list is written to a raw output parameter pointer using <a href="https://doc.rust-lang.org/beta/std/ptr/fn.copy.html"><code>std::ptr::copy</code></a>.</p>
<p>The library is built in the usual way with Cargo, storing the binary in <code>target/debug</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>cargo build
</span></span></code></pre></div><h1 id="python-ctypes-interface">Python Ctypes Interface</h1>
<p>Python wrappers to Rust libraries tend to follow a common layout pattern. Within the Rust project is found a directory named after the project, in this case <code>hash_set</code>. This is where the Python module lives. Create this directory and add the init file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>mkdir hash_set
</span></span><span style="display:flex;"><span>touch hash_set/__init__.py
</span></span></code></pre></div><p><code>__init.py</code> brings two objects within scope: a <code>lib</code> object exported from the <code>config</code> modules and representing the Rust library; and a <code>HashSet</code> class.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># hash_set/__init__.py</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> .config <span style="color:#f92672">import</span> lib
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> .hash_set <span style="color:#f92672">import</span> HashSet
</span></span></code></pre></div><p>The <code>lib</code> object is built through a call to <code>config/load_lib</code>. This function begins by tracking down the Rust library, then defining the argument types (<code>argstype</code>) and return types (<code>restype</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># hash_set/config.py</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">load_lib</span>():
</span></span><span style="display:flex;"><span>    prefix <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;win32&#39;</span>: <span style="color:#e6db74">&#39;&#39;</span>}<span style="color:#f92672">.</span>get(sys<span style="color:#f92672">.</span>platform, <span style="color:#e6db74">&#39;lib&#39;</span>)
</span></span><span style="display:flex;"><span>    extension <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;darwin&#39;</span>: <span style="color:#e6db74">&#39;.dylib&#39;</span>, <span style="color:#e6db74">&#39;win32&#39;</span>: <span style="color:#e6db74">&#39;.dll&#39;</span>}<span style="color:#f92672">.</span>get(sys<span style="color:#f92672">.</span>platform, <span style="color:#e6db74">&#39;.so&#39;</span>)
</span></span><span style="display:flex;"><span>    lib <span style="color:#f92672">=</span> ctypes<span style="color:#f92672">.</span>cdll<span style="color:#f92672">.</span>LoadLibrary(prefix <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;hash_map&#34;</span> <span style="color:#f92672">+</span> extension)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    lib<span style="color:#f92672">.</span>hash_set_new<span style="color:#f92672">.</span>restype <span style="color:#f92672">=</span> POINTER(HashSetS)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    lib<span style="color:#f92672">.</span>hash_set_len<span style="color:#f92672">.</span>argstype <span style="color:#f92672">=</span> (POINTER(HashSetS), POINTER(c_size_t), )
</span></span><span style="display:flex;"><span>    lib<span style="color:#f92672">.</span>hash_set_len<span style="color:#f92672">.</span>restype <span style="color:#f92672">=</span> c_int8
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    lib<span style="color:#f92672">.</span>hash_set_contains<span style="color:#f92672">.</span>argstype <span style="color:#f92672">=</span> (POINTER(HashSetS), POINTER(c_size_t), POINTER(c_bool), )
</span></span><span style="display:flex;"><span>    lib<span style="color:#f92672">.</span>hash_set_contains<span style="color:#f92672">.</span>restype <span style="color:#f92672">=</span> c_int8
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    lib<span style="color:#f92672">.</span>hash_set_insert<span style="color:#f92672">.</span>argstype <span style="color:#f92672">=</span> (POINTER(HashSetS), c_size_t)
</span></span><span style="display:flex;"><span>    lib<span style="color:#f92672">.</span>hash_set_insert_restype <span style="color:#f92672">=</span> c_bool
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    lib<span style="color:#f92672">.</span>hash_set_collect<span style="color:#f92672">.</span>argstype <span style="color:#f92672">=</span> (POINTER(HashSetS), POINTER(POINTER(c_size_t)), )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lib
</span></span></code></pre></div><p>The definition of argument and return types is made possible with <a href="https://docs.python.org/3/library/ctypes.html">ctypes</a>, &ldquo;a foreign function library for Python.&rdquo; As can be seen above, one of the jobs of ctypes is to help Python interpret the arguments and return values of FFI functions.</p>
<h1 id="python-api">Python API</h1>
<p>The <code>lib</code> object produced through ctypes assignment is available by importing it from the top-level module. The file <code>hash_set.py</code> leads with this import together with the import of types needed from the ctypes library.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># hash_set/hash_set.py</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> ctypes <span style="color:#f92672">import</span> c_size_t, c_bool, byref
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> hash_set <span style="color:#f92672">import</span> lib
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HashSet</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>obj <span style="color:#f92672">=</span> lib<span style="color:#f92672">.</span>hash_set_new()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __del__(self):
</span></span><span style="display:flex;"><span>        lib<span style="color:#f92672">.</span>hash_set_delete(self<span style="color:#f92672">.</span>obj)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ...</span>
</span></span></code></pre></div><p>The two methods <code>__init__</code> and <code>__del__</code> govern specific points in the lifecycle of <code>HashSet</code>. <code>__init__</code> is invoked just before the Python constructor returns. <code>__del__</code> is invoked sometime after a Python <code>HashSet</code> instance goes out of scope.</p>
<p>The remaining <code>HashSet</code> methods deal with the orchestration of Python ctypes and the Rust FFI library. As on the Rust side, a pattern emerges:</p>
<ol>
<li>instantiate and initialize ctypes</li>
<li>invoke the appropriate <code>lib</code> method</li>
<li>process the Rust FFI return value and ctypes</li>
<li>return a result or raise</li>
</ol>
<p>Take, for example, the <code>contains</code> method, which was was previously discussed from the Rust side.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># hash_set/hash_set.py</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HashSet</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">contains</span>(self, item):
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> c_bool()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> lib<span style="color:#f92672">.</span>hash_set_contains(self<span style="color:#f92672">.</span>obj, item, byref(result)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">ValueError</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> result<span style="color:#f92672">.</span>value
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ...</span>
</span></span></code></pre></div><p>The remaining <code>HashSet</code> methods follow a similar pattern. In analogy with the Rust side, the <code>collect</code> method deserves special mention.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># hash_set/hash_set.py</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HashSet</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">collect</span>(self):
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> (c_size_t <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>len())()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> lib<span style="color:#f92672">.</span>hash_set_collect(self<span style="color:#f92672">.</span>obj, byref(result)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">ValueError</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> list(result)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ...</span>
</span></span></code></pre></div><p><code>HashSet#collect</code> passes a pointer to a Python ctype array. The Rust side uses this pointer as a starting point to fill the array. However, the Python <code>c_size_t</code> instance must be instantiated with a length equal to the number of items in the Rust collection. A call to <code>self.len</code> makes this possible.</p>
<h1 id="testing">Testing</h1>
<p>From the outside, <code>HashMap</code> looks an acts like other Python classes. Instantiation works in the usual way, and there is no need for clients to explicitly &ldquo;destroy&rdquo; an instance after creation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>LD_LIBRARY_PATH<span style="color:#f92672">=</span>target/debug python3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; import hash_set
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; from hash_set import HashSet
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; s <span style="color:#f92672">=</span> HashSet<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; s.contains<span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>False
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; s.insert<span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>True
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; s.contains<span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>True
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; s.insert<span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>False
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; s.insert<span style="color:#f92672">(</span>1<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>True
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; s.len<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; s.collect<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>1, 0<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>Unix users should be able to use the <code>LD_LIBRARY_PATH</code> prefix to locate the library. Windows users can <a href="http://jakegoulding.com/rust-ffi-omnibus/basics/">copy the binary</a> into the current working directory.</p>
<h1 id="automation">Automation</h1>
<p>Building a Pythonic Rust wrapper at the low level presented here is very informative, but won&rsquo;t be right for every project. As we&rsquo;ve seen, past a point the work is pure repetition.</p>
<p>This raises the possibility of automating the process, but to my knowledge not much along these lines exists. <a href="https://github.com/rust-lang/rust-bindgen">Bindgen</a> &ldquo;automatically generates Rust FFI bindings to C (and some C++) libraries.&rdquo; This is not the direction of interest, which is to produce C FFI bindings to Rust libraries. At first glance, <a href="https://github.com/eqrion/cbindgen">cbindgen</a> looks promising, but it &ldquo;creates C/C++11 headers for Rust libraries which expose a public C API.&rdquo; We don&rsquo;t need headers. Finally, Swig doesn&rsquo;t yet <a href="https://github.com/swig/swig/issues/1468">directly</a> support Rust, although an indirect approach might be feasible. Rust Swig (aka <a href="https://github.com/Dushistov/flapigen-rs">flapigen-rs</a>) connects &ldquo;programs or libraries written in Rust with other languages,&rdquo; but so far Python is not directly supported. <a href="https://github.com/PyO3/pyo3">PyO3</a>, which has been discussed here <a href="/articles/2020/06/15/oxmol-rust-python-bindings-for-chemcore/">previously</a>, offers &ldquo;Rust bindings for Python,&rdquo; but the need to manually set up both the Python and Rust APIs remains.</p>
<p><a href="https://github.com/iduartgomez/rustypy">RustPy</a> appears to automate some of the tasks presented here, but I haven&rsquo;t worked with it and don&rsquo;t know the scope or limitations.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Hand-coded Python wrappers for Rust libraries are straightforward to build given some simple tools and concepts. The Rust side defines an interfaces of functions recapitulated on the the Python side as a class. The approach is fully capable of yielding wrappers that look and feel like ordinary Python libraries. What hasn&rsquo;t been discussed yet is packaging and distribution, but that&rsquo;s a story for another time.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Depth-First 2024 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
