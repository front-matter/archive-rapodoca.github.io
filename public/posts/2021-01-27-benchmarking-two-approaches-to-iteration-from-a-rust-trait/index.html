<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Benchmarking Iteration from a Rust Trait | My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Quantitating the relative performance of slices and boxed Iterators in graphs.">
    <meta name="generator" content="Hugo 0.139.4">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/2021-01-27-benchmarking-two-approaches-to-iteration-from-a-rust-trait/">
    

    <meta property="og:url" content="http://localhost:1313/posts/2021-01-27-benchmarking-two-approaches-to-iteration-from-a-rust-trait/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="Benchmarking Iteration from a Rust Trait">
  <meta property="og:description" content="Quantitating the relative performance of slices and boxed Iterators in graphs.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-01-26T19:00:00+00:00">
    <meta property="article:modified_time" content="2021-01-26T19:00:00+00:00">

  <meta itemprop="name" content="Benchmarking Iteration from a Rust Trait">
  <meta itemprop="description" content="Quantitating the relative performance of slices and boxed Iterators in graphs.">
  <meta itemprop="datePublished" content="2021-01-26T19:00:00+00:00">
  <meta itemprop="dateModified" content="2021-01-26T19:00:00+00:00">
  <meta itemprop="wordCount" content="2211">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Benchmarking Iteration from a Rust Trait">
  <meta name="twitter:description" content="Quantitating the relative performance of slices and boxed Iterators in graphs.">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Benchmarking Iteration from a Rust Trait</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2021-01-26T19:00:00Z">January 26, 2021</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Iterators are ubiquitous in Rust and mostly just work. Even so, Rust Iterators carry some noteworthy caveats. For an example, consider the case of returning an Iterator from a method defined on a trait. This article describes the problem and offers evidence supporting a practical and ergonomic solution.</p>
<h1 id="a-graph-trait">A Graph Trait</h1>
<p>Imagine designing a Rust crate for working with graphs. Here I&rsquo;m referring to the <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">mathematical construct</a>, not a <a href="https://en.wikipedia.org/wiki/Chart">chart</a>. The performance of many graph algorithms depends on the way graphs themselves are implemented. Two well-known extremes are <em><a href="https://en.wikipedia.org/wiki/Adjacency_list">adjacency lists</a></em> and <em><a href="https://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matricies</a></em>. An adjacency matrix uses a square matrix in which off-diagonal elements represent edges. An adjacency list uses a jagged list in which each element holds an array of neighbors. The two implementation perform exactly the same task, but with different performance tradeoffs. Various optimizations within each approach are known.</p>
<p>This situation, in which the same set of methods have multiple useful implementations, suggests the use of <em><a href="https://doc.rust-lang.org/book/ch10-02-traits.html">trait</a></em>. A Rust trait is a collection of method signatures that can be implemented by any type — now or in the future. Other languages use different names for the same concept. Java has &ldquo;interfaces.&rdquo; C++ has &ldquo;abstract classes.&rdquo; Duck-typed languages such as Ruby or JavaScript have nothing, but that&rsquo;s another story.</p>
<p>What should a <code>Graph</code> trait look like? A <a href="/articles/2020/01/06/a-minimal-graph-api/">previous article</a> examined this question in detail. To recap, only eleven methods are required. Three of them iterate values:</p>
<ul>
<li><code>ids</code>. Iterates the node IDs for the graph. Also known as <code>nodes</code>.</li>
<li><code>neighbors</code>. Iterates the node IDs for the neighbors of a node identified by its ID</li>
<li><code>edges</code>. Iterates edges as a pair of node identifiers.</li>
</ul>
<p>The minimal graph API is straightforward to implement in other languages using readily-available primitives such as maps and arrays. In Rust, however, things aren&rsquo;t so clear-cut. Those three methods above raise some difficult issues.</p>
<h1 id="the-problem">The Problem</h1>
<p>A <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">Rust iterator</a> is a value that implements the <code>Iterator</code> trait and its single method <code>next</code>. Rust takes this approach for the same reason that a <code>Graph</code> trait is desirable: there are many possible implementations, but it&rsquo;s more convenient for clients to work with a single type.</p>
<p>Returning an iterator from a method is easy. Consider, for example, a struct that owns a collection of integers. The goal is to provide a method for iterating them without revealing the underlying implementation. The code below is one way to do that. For details on the anonymous lifetime near the end of the method declaration (<code>'_</code>), see <a href="https://blog.katona.me/2019/12/29/Rust-Lifetimes-and-Iterators/">this</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Owner</span> {
</span></span><span style="display:flex;"><span>    ids: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Owner {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">ids</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">impl</span> Iterator<span style="color:#f92672">&lt;</span>Item<span style="color:#f92672">=</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> &#39;_ {
</span></span><span style="display:flex;"><span>        self.ids.iter().cloned()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> owner <span style="color:#f92672">=</span> Owner { ids: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> ] };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(owner.ids().collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>(), [ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> ])
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice that the private field <code>ids</code> could just as easily be replaced with a <code>Set</code>, a <code>HashSet</code>, or any other type that can produce an <code>Iterator</code>. In no case does a client need to know which <code>Iterator</code> implementation it receives. Moreover, the standard library makes several powerful iterator methods available for free. This is, of course, the power of Rust traits.</p>
<p>But there&rsquo;s a problem. Adding the <code>ids</code> method to a trait leads to an error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Owner {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ERROR💥: &#34;`impl Trait` not allowed outside of function and inherent method return types rustc(E0562)&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">ids</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">impl</span> Iterator<span style="color:#f92672">&lt;</span>Item<span style="color:#f92672">=</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> &#39;_;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <a href="https://doc.rust-lang.org/error-index.html#E0562">documentation for error E0562</a> informs us that:</p>
<blockquote>
<p>Abstract return types (written <code>impl Trait</code> for some trait Trait) are only allowed as function and inherent impl return types.</p>
</blockquote>
<p>In other words, returning a bare trait object from a trait method is not allowed. <a href="/articles/2020/06/22/returning-rust-iterators/">A previous article</a> discussed this situation in detail. To reiterate the conclusion, the best option for returning an iterator from a trait method: a boxed trait object.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Owner {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// NO ERROR!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">ids</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Iterator<span style="color:#f92672">&lt;</span>Item<span style="color:#f92672">=</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> &#39;_<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyOwner</span> {
</span></span><span style="display:flex;"><span>    ids: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Owner <span style="color:#66d9ef">for</span> MyOwner {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">ids</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Iterator<span style="color:#f92672">&lt;</span>Item<span style="color:#f92672">=</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> &#39;_<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        Box::new(self.ids.iter().cloned())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> owner <span style="color:#f92672">=</span> MyOwner { ids: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> ] };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(owner.ids().collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>(), [ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> ])
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a> is a heap-allocated pointer that automatically delegates the methods of the value it owns. As such, the return value can be used in exactly the same way as a concrete type. This is illustrated in the <code>test</code> function, which uses the <code>Iterator#collect</code> method as if it were defined on <code>Box</code>.</p>
<p>As discussed previously, it&rsquo;s technically possible to use associated types here as well. The <code>Owner</code> trait could, for example, be defined with an associated type <code>ItemIterator</code>. The main feature of this approach is that it does not require a <code>Box</code>. An <code>Iterator</code> can be returned directly from the <code>items</code> method by the implementor. And that could improve performance.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Owner2 {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ItemIterator</span>: Iterator<span style="color:#f92672">&lt;</span>Item<span style="color:#f92672">=</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">items</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">Self</span>::ItemIterator;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Unfortunately, all of my attempts to implement the <code>Owner2</code> trait have ultimately resulted in the introduction of a lifetime parameter. A way around this problem will have to await <a href="https://stackoverflow.com/questions/54161441/">generic associated types</a>. Suffice it to say that a library with a foundational type carrying a lifetime parameter (e.g., <code>Graph&lt;'a&gt;</code>) is going to be very hard to use.</p>
<p>Boxed iterators uniquely solve the problem today without introducing a lifetime parameter. But what about performance?</p>
<h1 id="boxed-iterator-performance">Boxed Iterator Performance</h1>
<p>To my knowledge, no 1:1 comparison of the performance of boxed iterators and an alternative has ever been published. A few hypotheses have been put forward, as can be seen in:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/28621980/">What are the actual runtime performance costs of dynamic dispatch?</a></li>
<li><a href="https://users.rust-lang.org/t/performance-implications-of-box-trait-vs-enum-delegation/11957">Performance implications of Box&lt;Trait&gt; vs enum delegation</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/74llky/trait_objects_22x_slower_than_static_dispatch/">trait objects: 22x slower than static dispatch?</a></li>
</ul>
<p>That third thread in particular raises a red flag. The last thing a trait should do is saddle its implementors with an extreme performance liability. Benchmarking might offer a way to dispel doubt.</p>
<h1 id="slice-based-iteration">Slice-Based Iteration</h1>
<p>At least one alternative to returning an iterator exists: return a slice instead. Clients can use exactly the same iteration pattern, while incurring none of the uncertainty of returning iterators from trait methods.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> Owner {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// slice 🍕, not Iterator 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">ids</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">usize</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyOwner</span> {
</span></span><span style="display:flex;"><span>    ids: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Owner <span style="color:#66d9ef">for</span> MyOwner {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">ids</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">usize</span>] {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self.ids
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> owner <span style="color:#f92672">=</span> MyOwner { ids: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> ] };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert_eq!(owner.ids().iter().collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>(), [ <span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span><span style="color:#ae81ff">2</span> ])
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The main problem with this approach is inflexibility. What if <code>MyOwner</code> were backed by a <code>HashSet</code>, <code>HashMap</code>, or another data structure that could not return a slice of values? Returning a slice from the <code>ids</code> method leaks a detail that constrains implementations. This undermines the very reasons to use a trait in the first place.</p>
<h1 id="two-graph-interfaces">Two Graph Interfaces</h1>
<p><a href="https://crates.io/crates/gamma">Gamma</a> is a Rust crate for working with graphs. It supports the minimal graph API through its <code>Graph</code> trait. Currently (v0.9.0), that trait uses the boxed Iterator pattern for its three iteration methods:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Graph {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns true if there are no nodes, or false otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">is_empty</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the number of nodes in this graph.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">order</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the number of edges in this graph.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">size</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns an Iterator over node identifiers.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">ids</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Iterator<span style="color:#f92672">&lt;</span>Item<span style="color:#f92672">=</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> &#39;_<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns an iterator over node identifiers for the neighbors at id,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// or Error if not found.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">neighbors</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self, id: <span style="color:#66d9ef">usize</span>
</span></span><span style="display:flex;"><span>    ) -&gt; Result<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Iterator<span style="color:#f92672">&lt;</span>Item<span style="color:#f92672">=</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> &#39;_<span style="color:#f92672">&gt;</span>, Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns true if id is a member, or false otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">has_id</span>(<span style="color:#f92672">&amp;</span>self, id: <span style="color:#66d9ef">usize</span>) -&gt; <span style="color:#66d9ef">bool</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the count of neighbors at id, or Error if id not found.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">degree</span>(<span style="color:#f92672">&amp;</span>self, id: <span style="color:#66d9ef">usize</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span>, Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns an iterator over the edges of this graph.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">edges</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Iterator<span style="color:#f92672">&lt;</span>Item<span style="color:#f92672">=</span>(<span style="color:#66d9ef">usize</span>, <span style="color:#66d9ef">usize</span>)<span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> &#39;_<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns true if the edge (sid, tid) exists, or false otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// Returns Error if either sid or tid are not found.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">has_edge</span>(<span style="color:#f92672">&amp;</span>self, sid: <span style="color:#66d9ef">usize</span>, tid: <span style="color:#66d9ef">usize</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span>, Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>More recently (v0.8.1), Gamma supported iteration with slices:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Graph {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns true if there are no nodes, or false otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">is_empty</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the number of nodes in this graph.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">order</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the number of edges in this graph.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">size</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the nodes of this graph.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">nodes</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">usize</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Iterates the neighbors of the node.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// Returns an error if id not found.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">neighbors</span>(<span style="color:#f92672">&amp;</span>self, id: <span style="color:#66d9ef">usize</span>) -&gt; Result<span style="color:#f92672">&lt;&amp;</span>[<span style="color:#66d9ef">usize</span>], Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns true if node is a member, or false otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">has_node</span>(<span style="color:#f92672">&amp;</span>self, id: <span style="color:#66d9ef">usize</span>) -&gt; <span style="color:#66d9ef">bool</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the count of neighbors at node. REturns an error if id not
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// found.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">degree</span>(<span style="color:#f92672">&amp;</span>self, id: <span style="color:#66d9ef">usize</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span>, Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns the edges of this graph.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">edges</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span>[(<span style="color:#66d9ef">usize</span>, <span style="color:#66d9ef">usize</span>)];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Returns true if the edge (sid, tid) exists, or false otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// Returns MissingNode if either sid or tid are not members.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">has_edge</span>(<span style="color:#f92672">&amp;</span>self, sid: <span style="color:#66d9ef">usize</span>, tid: <span style="color:#66d9ef">usize</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span>, Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Both versions support the same feature set, making it possible to benchmark them in a realistic setting.</p>
<h1 id="cargo-bench">Cargo Bench</h1>
<p>Cargo comes complete with its own benchmarking facility, Bencher. Unfortunately, it currently can only be used on <a href="https://rust-lang.github.io/rustup/concepts/channels.html">nightly</a>. Fortunately, installing nightly is simple, and once that&rsquo;s done Bencher is quite easy to use. Consider this example comparing <code>Vec</code> and <code>HashMap</code> as backing stores.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// benches/bench.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#![feature(test)]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> test;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> test::Bencher;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[cfg(test)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">mod</span> vec {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> <span style="color:#66d9ef">super</span>::<span style="color:#f92672">*</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[bench]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test</span>(b: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Bencher) {
</span></span><span style="display:flex;"><span>        b.iter(<span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> vec <span style="color:#f92672">=</span> Vec::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1000</span> {
</span></span><span style="display:flex;"><span>                vec.push(i <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f32</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3.5</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[cfg(test)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">mod</span> hash_map {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> <span style="color:#66d9ef">super</span>::<span style="color:#f92672">*</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[bench]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test</span>(b: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Bencher) {
</span></span><span style="display:flex;"><span>        b.iter(<span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> map <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1000</span> {
</span></span><span style="display:flex;"><span>                map.insert(i, i <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f32</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3.5</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Assuming that the above code has been saved in a Cargo project at <code>benches/bench.rs</code>, the benchmark can be run like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>$ cargo +nightly bench
</span></span><span style="display:flex;"><span>   Compiling bench_test v0.1.0 (/Users/rich/src/rust/bench_test)
</span></span><span style="display:flex;"><span>    Finished bench [optimized] target(s) in 0.86s
</span></span><span style="display:flex;"><span>     Running target/release/deps/bench_test-e50a864c98302e3c
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>running 0 tests
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>     Running target/release/deps/bench-3a4fcd802d8df8d5
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>running 2 tests
</span></span><span style="display:flex;"><span>test hash_map::test ... bench:      63,369 ns/iter (+/- 9,784)
</span></span><span style="display:flex;"><span>test vec::test      ... bench:       3,064 ns/iter (+/- 418)
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>test result: ok. 0 passed; 0 failed; 0 ignored; 2 measured; 0 filtered out; finished in 8.93s
</span></span></code></pre></div><p>Bencher reports two values for each test: an execution time in nanoseconds, and a range in nanoseconds representing the difference between the maximum and minimum values. In my hands, ranges of 15-40% are seen regularly. For details, see <a href="https://stackoverflow.com/questions/48323487/how-do-i-interpret-the-output-of-cargo-bench">this StackOverflow thread</a>.</p>
<h1 id="benchmarks">Benchmarks</h1>
<p>Gamma is a young library and as such currently supports a small set of graph algorithms. Fortunately, two are available which represent opposite extremes in complexity: depth-first traversal and <a href="https://stackoverflow.com/questions/48323487/how-do-i-interpret-the-output-of-cargo-bench">maximum matching</a>. These two tasks were chosen for some simple benchmarks.</p>
<p>The benchmark project itself is <a href="https://github.com/rapodaca/gamma_bench_itervslice">available on GitHub</a>. A graph composed of three fused cycles, corresponding to the <a href="https://en.wikipedia.org/wiki/Fluorene">fluorene molecular skeleton</a> was selected for traversal and maximum matching. The benchmark consists of two separate test suites, each performing a depth-first traversal and maximum matching on this graph but using different iteration techniques.</p>
<p>On my system, the results are as follows.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>$ cargo +nightly bench
</span></span><span style="display:flex;"><span>    Finished bench [optimized] target(s) in 0.00s
</span></span><span style="display:flex;"><span>     Running target/release/deps/bench-4a9b532fcd509670
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>running 0 tests
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>     Running target/release/deps/iter-11c609cfc9e969b8
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>running 2 tests
</span></span><span style="display:flex;"><span>test iter::dfs      ... bench:       5,399 ns/iter (+/- 766)
</span></span><span style="display:flex;"><span>test iter::matching ... bench:      54,178 ns/iter (+/- 19,450)
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>test result: ok. 0 passed; 0 failed; 0 ignored; 2 measured; 0 filtered out; finished in 6.57s
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>     Running target/release/deps/slice-c34b3389d0e977f6
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>running 2 tests
</span></span><span style="display:flex;"><span>test slice::dfs      ... bench:       3,465 ns/iter (+/- 1,398)
</span></span><span style="display:flex;"><span>test slice::matching ... bench:      46,862 ns/iter (+/- 19,335)
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>test result: ok. 0 passed; 0 failed; 0 ignored; 2 measured; 0 filtered out; finished in 0.72s
</span></span></code></pre></div><p>Absolute values differ from run to run, but in every case slice-based iteration outperforms boxed iterators. The difference is always most pronounced with depth-first traversal (about 50%), and less see with maximum matching (about 15%), although the latter are typically within the high/low range.</p>
<p>One other difference might be relevant. The boxed iterator used here clones its values, but the slice does not. To test the idea that cloning could play a role, a fork of the boxed iterator version (0.9.0) was created in which iterators return shared references (<code>Iterator&lt;Item=&amp;usize&gt;</code>). Benchmarks showed no difference in execution time.</p>
<p>The greater effect for depth-first traversal might be explained by the high relative share of iteration in that algorithm compared to maximum matching. When iteration accounts for a greater proportion of overall CPU activity, it can be expected to make a higher relative contribution to the execution time.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Exposing iterators from Rust traits presents a set of unique problems. Two viable options are discussed in the context of a <code>Graph</code> trait: boxed Iterator trait objects and slice-based iteration. In two benchmarks, slice-based iteration outperformed boxed Iterator traits. However, the difference in execution time was most pronounced with the simpler function (about 50% vs 15%). Given more complex functions of the kind likely to be seen in real-world applications, the runtime performance gap could narrow further.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  My New Hugo Site 2024 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
